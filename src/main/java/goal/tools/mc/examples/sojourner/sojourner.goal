main: sojournerAgent {
	knowledge{
	
		% Grid dimensions
		%grid(0,0,4,4).
		%grid(0,0,100,100).
		grid(0,0,200,200).
		
		% Determine next location
		
		%next(X1,Y1,Xnext,Ynext) :- X1 = 1 , Y1 = 2 , Xnext is 3 , Ynext is Y1 , !.
		next(X1,Y1,Xnext,Ynext) :- grid(Xmin,Ymin,Xmax,Ymax) , X1 < Xmax , Xnext is X1 + 1 , Ynext is Y1 , !.
		next(X1,Y1,Xnext,Ynext) :- grid(Xmin,Ymin,Xmax,Ymax) , X1 = Xmax , Y1 < Ymax , Xnext is 0 , Ynext is Y1 + 1 , !.
		%next(X1,Y1,Xnext,Ynext) :- grid(Xmin,Ymin,Xmax,Ymax) , X1 = Xmax , Y1 = Ymax , Xnext is X1 , Ynext is Y1 , !.
		
		%next(X1,Y1,Xnext,Ynext) :- grid(Xmin,Ymin,Xmax,Ymax) , X1 < Xmax , Xnext is X1 + 1 , Ynext is Y1.
		%next(X1,Y1,Xnext,Ynext) :- grid(Xmin,Ymin,Xmax,Ymax) , X1 > Xmin , Xnext is X1 - 1 , Ynext is Y1.
		%next(X1,Y1,Xnext,Ynext) :- grid(Xmin,Ymin,Xmax,Ymax) , Y1 < Ymax , Xnext is X1 , Ynext is Y1 + 1.
		%next(X1,Y1,Xnext,Ynext) :- grid(Xmin,Ymin,Xmax,Ymax) , Y1 > Ymin , Xnext is X1 , Ynext is Y1 - 1.
		
		%next(X1,Y1,Xnext,Ynext) :- dir(0) , 1 is Y1 mod 2 , grid(Xmin,Ymin,Xmax,Ymax) , X1 < Xmax , Xnext is X1 + 1 , Ynext is Y1 , !.
		%next(X1,Y1,Xnext,Ynext) :- dir(0) , 1 is Y1 mod 2 , grid(Xmin,Ymin,Xmax,Ymax) , X1 = Xmax , Y1 > Ymin , Xnext is X1 , Ynext is Y1 - 1 , !.
		%next(X1,Y1,Xnext,Ynext) :- dir(0) , 0 is Y1 mod 2 , grid(Xmin,Ymin,Xmax,Ymax) , X1 > Xmin , Xnext is X1 - 1 , Ynext is Y1 , !.
		%next(X1,Y1,Xnext,Ynext) :- dir(0) , 0 is Y1 mod 2 , grid(Xmin,Ymin,Xmax,Ymax) , X1 = Xmim , Y1 > Ymin , Xnext is X1 , Ynext is Y1 - 1 , !.
		
		%next(X1,Y1,Xnext,Ynext) :- dir(1) , 0 is Y1 mod 2 , grid(Xmin,Ymin,Xmax,Ymax) , X1 < Xmax , Xnext is X1 + 1 , Ynext is Y1 , !.
		%next(X1,Y1,Xnext,Ynext) :- dir(1) , 0 is Y1 mod 2 , grid(Xmin,Ymin,Xmax,Ymax) , X1 = Xmax , Y1 < Ymax , Xnext is X1 , Ynext is Y1 + 1 , !.
		%next(X1,Y1,Xnext,Ynext) :- dir(1) , 1 is Y1 mod 2 , grid(Xmin,Ymin,Xmax,Ymax) , X1 > Xmin , Xnext is X1 - 1 , Ynext is Y1 , !.
		%next(X1,Y1,Xnext,Ynext) :- dir(1) , 1 is Y1 mod 2 , grid(Xmin,Ymin,Xmax,Ymax) , X1 = Xmim , Y1 < Ymax , Xnext is X1 , Ynext is Y1 + 1 , !.
		
		% Determine next location in (Xl,Yl)'s direction
		towards(X1,Y1,Xl,Yl,Xnext,Ynext) :- step(X1,Xl,XS) , step(Y1,Yl,YS) , Xnext is X1 + XS , Ynext is Y1 + YS.
		step(P1,P2,S) :- P1 < P2 , S is 1 , !.
		step(P1,P2,S) :- P1 = P2 , S is 0 , !.
		step(P1,P2,S) :- P1 > P2 , S is -1 , !.
		
		%towards(X1,Y1,Xl,Yl,Xnext,Ynext) :- X1 < Xl , Xnext is X1 + 1 , Ynext is Y1 , !.
		%towards(X1,Y1,Xl,Yl,Xnext,Ynext) :- X1 > Xl , Xnext is X1 - 1 , Ynext is Y1 , !.
		%towards(X1,Y1,Xl,Yl,Xnext,Ynext) :- Y1 < Yl , Xnext is X1 , Ynext is Y1 + 1 , !.
		%towards(X1,Y1,Xl,Yl,Xnext,Ynext) :- Y1 > Yl , Xnext is X1 , Ynext is Y1 - 1 , !.
		
		% Garbage detection
		atGarbage(r1) :- pos(r1,X1,Y1) , garbageAt(X1,Y1).
	
		% Abbreviations
		take(S,L) :- pos(back,X1,Y1) , not(garbageAt(X1,Y1)) , pos(r1,X1,Y1).
		ensure_pick(S) :- pos(back,X1,Y1) , not(garbageAt(X1,Y1)).
		go(L) :- pos(L,Xl,Yl) , pos(r1,Xl,Yl).
	}
	
	beliefs{
	
		%dir(0)
		%pos(r2,2,2).
		%pos(r2,50,50).
		pos(r2,100,100).
		
		pos(r1,0,0).
		checking(slots).
		
		%garbageAt(4,4).
		%garbageAt(100,100).
		garbageAt(200,200).
	}
	
	goals{
		
	}
	
	program[order=random]{
		
		if bel( checking(slots) , atGarbage(r1) ) then stop(check).
		if bel( not(checking(slots)) , atGarbage(r1) ) then adopt( take(garb,r2) ).
		if bel( not(checking(slots)) , not(atGarbage(r1)) ) then continue(check).
		if bel( checking(slots) , not(atGarbage(r1)) ) then next(slot).
		%if bel( pos(r1,X1,X2) , not(next(X1,X2,Xnext,Ynext)) ) then turn.
		
		% Dirty hack to incorporate r2.
		if bel( garbage(r2) ) then burn(garb) .
		
		module p2{
			context[focusmethod=filter]{
				a-goal( take(garb,r2) )
			}
			program[order=linear]{
				
				if a-goal( take(S,L) ) , not(goal( ensure_pick(S) , go(L) )) then adopt( ensure_pick(S) , go(L) ).
				
				% Mimics plan p5 and p6
				module p5_and_p6{
					context[focusmethod=filter]{
						a-goal(ensure_pick(S))
					}
					program[order=random]{
						if bel( not(attempts(I)) ) then pick(garb).
						if bel( attempts(I) ) then pick(garb) + delete(attempts(I)).
						if bel( not(attempts(I)) ) then insert(attempts(1)).
						if bel( true ) then increment.
						
						% Dirty hack to incorporate r2.
						if bel( garbage(r2) ) then burn(garb).
					}
					actionspec{
						pick(garb){
							pre{ pos(r1,X1,Y1) , garbageAt(X1,Y1) }
							post{ not(garbageAt(X1,Y1)) , garbage(r1) }
						}
						increment{
							pre{ attempts(I), I<2, Inew is I+1 }
							post{ not(attempts(I)), attempts(Inew) }
						}
					}
				}
				
				% Mimics plan p8 and p9
				module p8_and_p9{
					context[focusmethod=filter]{
						a-goal(go(L))
					}
					program[order=random]{
						if a-goal(go(L)) , bel( pos(L,Xl,Yl) ) then moveTowards(Xl,Yl).
						
						% Dirty hack to incorporate r2.
						if bel( garbage(r2) ) then burn(garb).
					}
					actionspec{
						moveTowards(Xl,Yl) {
							pre{ pos(r1,X1,Y1) , towards(X1,Y1,Xl,Yl,Xnext,Ynext) }
							post{ not(pos(r1,X1,Y1)) , pos(r1,Xnext,Ynext) }
						}
					}
				}
				
				% Mimics plan p7
				if bel( pos(back,X1,Y1) , not(pos(r1,X1,Y1)) ) then drop_(garb) + adopt( go(back) ).
			}
		}
	}
	actionspec{
		next(slot) {
			pre{ pos(r1,X1,Y1) , next(X1,Y1,Xnext,Ynext) }
			post{ not(pos(r1,X1,Y1)) , pos(r1,Xnext,Ynext) }
		}
		%turn {
		%	pre{ dir(D) , Dtemp is D+1 , Dnew is Dtemp mod 2 }
		%	post{ not(dir(D)) , dir(Dnew) }
		%}
		stop(check) {
			pre{ pos(r1,X1,Y1) }
			post{ pos(back,X1,Y1) , not(checking(slots)) }
		}
		continue(check) {
			pre{ pos(back,X1,Y1) }
			post{ not(pos(back,X1,Y1)) , checking(slots) }
		}
		drop_(garb){
			pre{ pos(r1,X1,Y1) , garbage(r1) , pos(r2,X1,Y1) }
			post{ not(garbage(r1)) , garbage(r2) }
		}
		burn(garb){
			pre{ garbage(r2) }
			post{ not(garbage(r2)) }
		}
	}
}

%
% === 101 x 101 ===
%
% [REPORT] Stored 20737 product states (1 dummy), computed 10367 program states (1 dummy)
%
% Java memory:          33772224 B = 32980 KB = 32 MB
% Prolog memory:        592908 B = 579 KB = 0 MB
% Java + Prolog memory: 34365132 B = 33559 KB = 32 MB
%
% Elapsed time:         128295 ms = 128 s = 2 min
% 
% === 201 x 201 ===
%
% [REPORT] Stored 81437 product states (1 dummy), computed 40717 program states (1 dummy)
% 
% Java memory:          182544816 B = 178266 KB = 174 MB
% Prolog memory:        592908 B = 579 KB = 0 MB
% Java + Prolog memory: 183137724 B = 178845 KB = 174 MB
% 
% Elapsed time:         2241857 ms = 2241 s = 37 min
