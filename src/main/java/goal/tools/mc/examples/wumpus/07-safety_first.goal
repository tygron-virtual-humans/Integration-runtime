main: wumpusAgent
{
	knowledge{
% returns the coordinaties to the room in front of the agent
		next(X,Y,0,X2,Y) :- X2 is X+1.
		next(X,Y,1,X,Y2) :- Y2 is Y-1.
		next(X,Y,2,X2,Y) :- X2 is X-1.
		next(X,Y,3,X,Y2) :- Y2 is Y+1.
% returns the coordinates of the room to the left side of the agent
		leftside(X,Y,0,X,Y2) :- Y2 is Y+1.
		leftside(X,Y,1,X2,Y) :- X2 is X+1.
		leftside(X,Y,2,X,Y2) :- Y2 is Y-1.
		leftside(X,Y,3,X2,Y) :- X2 is X-1.
% returns the coordinates of the room to the right side of the agent
		rightside(X,Y,0,X,Y2) :- Y2 is Y-1.
		rightside(X,Y,1,X2,Y) :- X2 is X-1.
		rightside(X,Y,2,X,Y2) :- Y2 is Y+1.
		rightside(X,Y,3,X2,Y) :- X2 is X+1.
% returns the coordinaties to the room behind the agent
		behind(X,Y,0,X2,Y) :- X2 is X-1.
		behind(X,Y,1,X,Y2) :- Y2 is Y+1.
		behind(X,Y,2,X2,Y) :- X2 is X+1.
		behind(X,Y,3,X,Y2) :- Y2 is Y-1.
% used to return all visited rooms next to the agent that aren't walls
		adj(X,Y,T) :- X1 is X+1, visited(X1,Y,T), not(wall(X1,Y,_)).
		adj(X,Y,T) :- X1 is X-1, visited(X1,Y,T), not(wall(X1,Y,_)).
		adj(X,Y,T) :- Y1 is Y+1, visited(X,Y1,T), not(wall(X,Y1,_)).
		adj(X,Y,T) :- Y1 is Y-1, visited(X,Y1,T), not(wall(X,Y1,_)).
% returns all rooms adjacent to the agent that are safe
		adjs(X,Y,(X1,Y)) :- X1 is X+1, safe(X1,Y).
		adjs(X,Y,(X1,Y)) :- X1 is X-1, safe(X1,Y).
		adjs(X,Y,(X,Y1)) :- Y1 is Y+1, safe(X,Y1).
		adjs(X,Y,(X,Y1)) :- Y1 is Y-1, safe(X,Y1).
% returns all rooms adjacent to the agent, which he has visited already
		adjv(X,Y,(X1,Y)) :- X1 is X+1, visited(X1,Y,_).
		adjv(X,Y,(X1,Y)) :- X1 is X-1, visited(X1,Y,_).
		adjv(X,Y,(X,Y1)) :- Y1 is Y+1, visited(X,Y1,_).
		adjv(X,Y,(X,Y1)) :- Y1 is Y-1, visited(X,Y1,_).
% returns teh minimum element of a list
		minList([E],E) :- !.
		minList([H1,H2|T],E) :- H1 < H2, minList([H1|T],E), !.
		minList([H1,H2|T],E) :- minList([H2|T],E), !.
% returns the timestamp of the room adjacent to the agent that has been visited least recently
		bestMove(X,Y,T) :- findall(L,adj(X,Y,L),L), minList(L,T).
% checks if the agent has visited all the safe rooms adjacent to him
		safeVisited(X,Y) :- findall([X1,Y1],adjs(X,Y,(X1,Y1)),L), findall([X2,Y2],adjv(X,Y,(X2,Y2)),L1), subsett(L,L1).
% returns true if the first argument is a subset of the second argument
		subsett([H|T],L) :- in(H,L), subsett(T,L).
		subsett([],_).
% checks if an element exists in a list
		in(H,[H|_]).
		in(H,[_|T]) :- in(H,T).
	}
% original beliefs about the world
	beliefs{
		hasarrow.
		wumpusisalive.
		position(1,1,0).
	}
% goals for the agent to achieve
	goals{
		hasgold.
		getoutofthiscave.
	}

	program{

% changes the state of the rooms adjacent to the agents based on his perceptions of the world
		if bel(position(X,Y,_), smelly(X,Y,T), not(breezy(X,Y,T)), not(wumpusisalive)) then safeSmell(T).
		if bel(position(X,Y,_), safeAss(X,Y,T1)) then updateroom(safe).

% if the agent has spent too much time searching for the gold, make preparations to escape
		if bel(run) then runaway.
		if bel(position(X,Y,_), wall(X,Y,T)) then backward.
		if bel(position(X,Y,_), gold(X,Y,T)), goal(hasgold) then grab.
% if the agent has the gold and is back at the starting sqare, climb to safety
		if bel(position(1,1,_), hasgold) then climb.

% rules to determine if the wumpus is close, and if so kill it
		if bel(position(X,Y,Q), smelly(X,Y,_), next(X,Y,Q,X1,Y1), next(X1,Y1,Q,X2,Y2), smelly(X2,Y2,_), wumpusisalive) then shoot.
		if bel(position(X,Y,Q), smelly(X,Y,_), leftside(X,Y,Q,X1,Y1), leftside(X1,Y1,Q,X2,Y2), smelly(X2,Y2,_)) then turn(left).		
		if bel(position(X,Y,Q), smelly(X,Y,_), rightside(X,Y,Q,X1,Y1), rightside(X1,Y1,Q,X2,Y2), smelly(X2,Y2,_)) then turn(right).
		if bel(position(X,Y,Q), smelly(X,Y,_), leftside(X,Y,Q,X1,Y1), next(X1,Y1,Q,X2,Y2), smelly(X2,Y2,_), safe(X1,Y1)) then shoot.
		if bel(position(X,Y,Q), smelly(X,Y,_), rightside(X,Y,Q,X1,Y1), next(X1,Y1,Q,X2,Y2), smelly(X2,Y2,_), safe(X1,Y1)) then shoot.
		if bel(position(X,Y,Q), smelly(X,Y,_), next(X,Y,Q,X1,Y1), leftside(X1,Y1,Q,X2,Y2), smelly(X2,Y2), safe(X1,Y1)) then turn(left).
		if bel(position(X,Y,Q), smelly(X,Y,_), next(X,Y,Q,X1,Y1), rightside(X1,Y1,Q,X2,Y2), smelly(X2,Y2), safe(X1,Y1)) then turn(right).
		if bel(position(X,Y,Q), smelly(X,Y,_), rightside(X,Y,Q,X1,Y1), wall(X1,Y1,_), leftside(X,Y,Q,X2,Y2), wall(X2,Y2,_), wumpusisalive) then shoot.

% rules to visit rooms not yet visited
		if bel(position(X,Y,Q), not(wall(X,Y,_)), visited(X,Y,_), next(X,Y,Q,X2,Y2), safe(X2,Y2), not(visited(X2,Y2,_)), not(hasgold)) then forward.
		if bel(position(X,Y,Q), not(wall(X,Y,_)), visited(X,Y,_), next(X,Y,Q,X2,Y2), visited(X2,Y2,_), leftside(X,Y,Q,X3,Y3), not(visited(X3,Y3,_)), safe(X3,Y3), not(hasgold)) then turn(left).
		if bel(position(X,Y,Q), not(wall(X,Y,_)), visited(X,Y,_), next(X,Y,Q,X2,Y2), visited(X2,Y2,_), rightside(X,Y,Q,X3,Y3), not(visited(X3,Y3,_)), safe(X3,Y3), not(hasgold)) then turn(right).
		if bel(position(X,Y,Q), not(wall(X,Y,_)), visited(X,Y,_), next(X,Y,Q,X2,Y2), visited(X2,Y2,_), behind(X,Y,Q,X3,Y3), not(visited(X3,Y3,_)), safe(X3,Y3), not(hasgold)) then turn(left).

% rule that says what to do in the event of the agent facing an unsafe room
		if bel(position(X,Y,Q), visited(X,Y,_), next(X,Y,Q,X2,Y2), not(safe(X2,Y2))) then turn(left).

% rules to determine what the best move is, if all adjacent rooms have already been visited
		if bel(not(hasgold), not(scream), position(X,Y,Q), not(wall(X,Y,_)), visited(X,Y,_), next(X,Y,Q,X2,Y2), safeVisited(X,Y), bestMove(X,Y,T), visited(X2,Y2,T)) then forward.
		if bel(not(hasgold), not(scream), position(X,Y,Q), not(wall(X,Y,_)), visited(X,Y,_), next(X,Y,Q,X2,Y2), visited(X2,Y2,_), safeVisited(X,Y), bestMove(X,Y,T), visited(Xbest,Ybest,T), rightside(X,Y,Q,Xbest,Ybest)) then turn(right).
		if bel(not(hasgold), not(scream), position(X,Y,Q), not(wall(X,Y,_)), visited(X,Y,_), next(X,Y,Q,X2,Y2), visited(X2,Y2,_), safeVisited(X,Y), bestMove(X,Y,T), visited(Xbest,Ybest,T), leftside(X,Y,Q,Xbest,Ybest)) then turn(left).
		if bel(not(hasgold), not(scream), position(X,Y,Q), not(wall(X,Y,_)), visited(X,Y,_), next(X,Y,Q,X2,Y2), visited(X2,Y2,_), safeVisited(X,Y), bestMove(X,Y,T), visited(Xbest,Ybest,T), behind(X,Y,Q,Xbest,Ybest)) then turn(left).

% rules for running back to the entrance if the gold has been found
		if bel(hasgold, position(X,Y,Q), not(position(1,1,_)), next(X,Y,Q,X2,Y2), visited(X,Y,_), bestMove(X,Y,T), visited(X2,Y2,T)) then forward.
		if bel(hasgold, position(X,Y,Q), not(position(1,1,_)), next(X,Y,Q,X2,Y2), visited(X,Y,_), bestMove(X,Y,T), visited(Xbest,Ybest,T), rightside(X,Y,Q,Xbest,Ybest)) then turn(right).
		if bel(hasgold, position(X,Y,Q), not(position(1,1,_)), next(X,Y,Q,X2,Y2), visited(X,Y,_), bestMove(X,Y,T), visited(Xbest,Ybest,T), leftside(X,Y,Q,Xbest,Ybest)) then turn(left).
		if bel(hasgold, position(X,Y,Q), not(position(1,1,_)), next(X,Y,Q,X2,Y2), visited(X,Y,_), bestMove(X,Y,T), visited(Xbest,Ybest,T), behind(X,Y,Q,Xbest,Ybest)) then turn(left).

	}

	actionspec{
			climb {
				pre{ true }
				post{ foo }
			}
			shoot {
				pre{ hasarrow }
				post{ not(hasarrow) , not(wumpusisalive)}
			}
% makes sqares next to smelly squares safe if the wumpus is dead and there is no breeze
			safeSmell(T) {
				pre { position(X,Y,_), (N is Y+1), (E is X+1), (W is X-1), (S is Y-1) }
				post { visited(X,Y,T), safe(X,Y),	safe(E,Y),	safe(W,Y),	safe(X,N),	safe(X,S) }
			}
% change position backwards if the agent walks into a wall
			backward {
				pre{ position(X,Y,Q), wall(X,Y,T), behind(X,Y,Q,X1,Y1) }
				post{ visited(X,Y,T), position(X1,Y1,Q), not(position(X,Y,Q)) }
			}
% if null perception is received, make all adjacent rooms safe
			updateroom(safe){
				pre{ position(X,Y,_), (N is Y+1), (E is X+1), (W is X-1), (S is Y-1), safeAss(X,Y,T) }
				post{	visited(X,Y,T), safe(X,Y),	safe(E,Y),	safe(W,Y),	safe(X,N),	safe(X,S), not(safeAss(X,Y,T)) }
			}
			grab {
				pre{ position(X,Y,_), gold(X,Y,T) }
				post{ not(gold(X,Y,T)), hasgold, visited(X,Y,T) }
			}
% predicate to runaway if the gold is not found within a certain time
			runaway {
				pre{ true }
				post{ hasgold }
			}
			forward {
				pre{ position(X,Y,Q), next(X,Y,Q,X2,Y2) }
				post{ position(X2,Y2,Q), not(position(X,Y,Q)) }
			}
			turn(left) {
				pre{ position(X,Y,0) }
				post{ not(position(X,Y,0)), position(X,Y,3) }
			}
			turn(left) {
				pre{ position(X,Y,Z), Z\=0, G is Z-1 }
				post{ not(position(X,Y,Z)), position(X,Y,G) }
			}
			turn(right) {
				pre{ position(X,Y,3) }
				post{ not(position(X,Y,3)), position(X,Y,0) }
			}
			turn(right) {
				pre{ position(X,Y,Z), Z\=3, G is Z+1 }
				post{ not(position(X,Y,Z)), position(X,Y,G) }
			}
	}
}

======================== PERCEPT RULES =========================================



	perceptrules{
% if too long time has passed in the cave, ignore the gold and run away
		when input{ percept([_,_,_,_,_],T), T == 373 } do update{ run }.
		when input{ percept([_,stench,_,_,_],T), position(X,Y,_), not(visited(X,Y,_)) } do update{ smelly(X,Y,T), visited(X,Y,T) }.
		when input{ percept([breeze,_,_,_,_],T), position(X,Y,_), not(visited(X,Y,_)) } do update{ breezy(X,Y,T), visited(X,Y,T) }.
		when input{ percept([_,_,bump,_,_],T), position(X,Y,_) } do update{ wall(X,Y,T) }.
		when input{ percept([_,_,_,scream,_],T) } do update{ not(wumpusisalive) }.
		when input{ percept([_,_,_,_,glitter],T), position(X,Y,_) } do update{ gold(X,Y,T) }.
		when input{ percept([null,null,null,null,null],T), position(X,Y,_), not(visited(X,Y,_)) } do update{ safeAss(X,Y,T) }.
% if the agent has already been in this room, update the timestamp of the rooms latest visit
		when input{ percept([_,_,_,_,_],T), position(X,Y,_), visited(X,Y,Told)} do update{ visited(X,Y,T), not(visited(X,Y,Told)) }.
	}
	
	
============================ SLICING RESULTS ===================================



{if this.bel(position(1,1,_) , drop(hasgold)) then climb.}

[SLICER] retained 26 of 27 rules

Functors: {hasarrow}