main: wumpusAgent
{
	knowledge{


		% Based on Lee Routing Algorithm in The Art of Prolog, pp. 275-276

		% Compute next action for shortest path to Pos
		% Assumes that agent currently is at initial position of path with current orientation
		
		% Action can be forward, left, right
		% [A,B] is coordinate of target
		% shortestPathTo returns true iff the specified action is the right action to get to point (A,B)
		shortestPathTo(A,B,Action) :- 
			% Ensure the target is valid
			dontKillYourself(A,B),

			% Read context
			at(X,Y), 
			orient(Z), 

			% Find shortest path, put in Path1
			shortestPathPlanner(X,Y,A,B,Path1),

			% Reverse so the first action in the plan becomes the head
			reverse(Path1,Path2),

			% Ensure that the suggested action is OK with the calculated plan
			extract_plan(Path2,[Action|_],Z,_).
		
		% [A,B] is target coordinates
		shortestPathPlanner(X,Y,A,B,Path) :- 
			waves(A,B,[[[X,Y]],[]],Waves), 
			path([X,Y],[A,B],Waves,Path).
			
		% Planner part 1, determine valid waves
		waves(A,B,[Wave|Waves],Waves) :- 
			% The desired location is at the end of the wave, were done!
			member([A,B],Wave),!.
		waves(A,B,[Wave,LastWave|LastWaves],Waves) :- 
			% ensure new move is possible from the last
			next_wave(Wave,LastWave,NextWave),
			% continue, doublecheck
			waves(A,B,[NextWave,Wave,LastWave|LastWaves],Waves).
		
		next_wave(Wave,LastWave,NextWave) :- 
			% NextWave is a set of X such that for all X hold that it is
			% admissible for Wave and Lastwave
			setof(X,admissible(X,Wave,LastWave),NextWave).
		
		% filters invalid positions
		admissible(Pos,Wave,LastWave) :- 
			neighbor(Pos,Wave), 
			not(member(Pos,LastWave)), 
			not(member(Pos,Wave)).
		
		neighbor([X,Y],Wave) :- 
			member(Pos1,Wave), 
			adjacent([X,Y],Pos1), 
			% The coordinate must be free for visiting
			% at(Pos,_).
			dontKillYourself(X,Y).
		
		adjacent([X1,Y],[X2,Y]) :- 
			next_to(X1,X2).
		adjacent([X,Y1],[X,Y2]) :- 
			next_to(Y1,Y2).
		
		next_to(A,B) :- 
			is(A,+(B,1)).
		next_to(A,B) :- 
			is(A,-(B,1)).
		
		% Part 2, find the actions
		path(Pos,Pos,_,[Pos]) :- 
			!.
		path(Pos1,Pos2,[Wave|Waves],[Pos2|Path]) :-
			member(Pos,Wave), 
			adjacent(Pos,Pos2), 
			!, 
			path(Pos1,Pos,Waves,Path).
		
		% extract_plan(Positions, Actions, Direction, NewDirection)
		% Positions: List of coordinates, the path.
		% Actions: List of actions that match the path
		% Direction: The current orientation
		% NewDirection: The orientation after the action(s)
		
		% Nothing to do
		extract_plan([], [], A, A).
		
		% Arrived at location
		extract_plan([_], [], A, A).
		
		% Step forward
		extract_plan([Pos1,Pos2], [forward],Z,Z) :- 
			inFrontOf(Pos1,Z,Pos2).
		
		% Turn left and forward
		extract_plan([Pos1,Pos2], [left,forward], Dir, NewDir) :-
			is(NewDir,mod(+(Dir,1),4)), 
			inFrontOf(Pos1,NewDir,Pos2).
		
		% Turn right and forward
		extract_plan([Pos1,Pos2], [right,forward], Dir, NewDir) :-
			is(NewDir,mod(+(Dir,3),4)), 
			inFrontOf(Pos1,NewDir,Pos2).
		
		% Turn around and forward
		extract_plan([Pos1,Pos2], [left,left,forward], Dir, NewDir) :-
			is(NewDir,mod(+(Dir,2),4)), 
			inFrontOf(Pos1,NewDir,Pos2).
		
		% In case the path is longer than 2 coords
		% Split the plan into smaller extract_plan calls
		extract_plan([Pos1,Pos2|PathTail], Plan, Dir, _) :-
			% Safety: The length of PathTail MUST be > 0 otherwise this function should not be used
			listlength(PathTail,Len),
			% write(Len),
			Len > 0,
			
			% extract plan for first two positions, store this as Plan1
			% with the updated orientation in NewDir
			extract_plan([Pos1,Pos2],Plan1,Dir,NewDir), 

			% Recursion on the remaining path from Pos2
			extract_plan([Pos2|PathTail],Plan2,NewDir,_),

			append(Plan1,Plan2,Plan).

		% OMG Why cant I use basic prolog functions in GOAL???
		% Replacement length(List, Number) function, which does not work in GOAL
		listlength([],0).
		listlength([_],1).
		listlength([_|T], N):-  
			listlength(T, N1),  
			N is N1 + 1.		

		% 0 degrees =>
		inFrontOf([X1,Y],0,[X2,Y]) :-
			is(X2,+(X1,1)).
		
		% 90 degrees /\
		inFrontOf([X,Y1],1,[X,Y2]) :-
			is(Y2,+(Y1,1)).
		
		% 180 degrees <=
		inFrontOf([X1,Y],2,[X2,Y]) :-
			is(X2,-(X1,1)).
		
		% 270 degrees \/
		inFrontOf([X,Y1],3,[X,Y2]) :-
			is(Y2,-(Y1,1)).

		% End of PATHPLANNER /\ /\ /\

		% Post: Returns true if the agent can safely stand at this location,
		dontKillYourself(0,0).
		% Exploration:
		dontKillYourself(X,Y) :-
			not(hasgold),
			% avoid hitting wumpus 
			not(wumpusAt(X,Y)), not(posWumpusAt(X,Y)),
			% avoid bumping in same wall twice
			not( wall(X,Y)),
			% avoid pit
			not(pitAt(X,Y)).
		% Exit strategy:
		dontKillYourself(X,Y) :-
			hasgold,
			beenthere(X,Y).
	


		%%%%%%%%%% determining next step approach is as follows:
			%%% check if it is possible to move to the right
			%% if so move right, otherwise check if possible to move forward**
			%% if not turn left, and check for moving forward..etc. etc.

			%% ** if move forward is free, but leads to an already known place, first check for unknown but safe places
			%% around the current location.

		%% find out if X,Y is next to beenthere
		nextToKnown(Xnew,Ynew) :- beenthere(X,Y), Xnew is X+1, Ynew is Y.
		nextToKnown(Xnew,Ynew) :- beenthere(X,Y), Xnew is X, Ynew is Y+1.
		nextToKnown(Xnew,Ynew) :- beenthere(X,Y), Xnew is X-1, Ynew is Y.
		nextToKnown(Xnew,Ynew) :- beenthere(X,Y), Xnew is X, Ynew is Y-1.

		%% find out if X,Y is possible exploration space (safe but unknown)
		posExplore(X,Y) :- 
			nextToKnown(X,Y),
			not(beenthere(X,Y)),
			not(wall(X,Y)),
			not(posWumpusAt(X,Y)),
			not(wumpusAt(X,Y)),
			not(pitAt(X,Y)).

		%% location after right turn
		locRightForward(Xnew,Ynew) :- at(X,Y), orient(0), Xnew is X, Ynew is Y-1.
		locRightForward(Xnew,Ynew) :- at(X,Y), orient(1), Xnew is X+1, Ynew is Y.
		locRightForward(Xnew,Ynew) :- at(X,Y), orient(2), Xnew is X, Ynew is Y+1.
		locRightForward(Xnew,Ynew) :- at(X,Y), orient(3), Xnew is X-1, Ynew is Y.

		%% location after left turn
		locLeftForward(Xnew,Ynew) :- at(X,Y), orient(0), Xnew is X, Ynew is Y+1.
		locLeftForward(Xnew,Ynew) :- at(X,Y), orient(1), Xnew is X-1, Ynew is Y.
		locLeftForward(Xnew,Ynew) :- at(X,Y), orient(2), Xnew is X, Ynew is Y-1.
		locLeftForward(Xnew,Ynew) :- at(X,Y), orient(3), Xnew is X+1, Ynew is Y.

		%% Location after 180
		loc180Forward(Xnew,Ynew) :- at(X,Y), orient(0), Xnew is X-1, Ynew is Y.
		loc180Forward(Xnew,Ynew) :- at(X,Y), orient(1), Xnew is X, Ynew is Y-1.
		loc180Forward(Xnew,Ynew) :- at(X,Y), orient(2), Xnew is X+1, Ynew is Y.
		loc180Forward(Xnew,Ynew) :- at(X,Y), orient(3), Xnew is X, Ynew is Y+1.

		%% location after forward
		locForward(Xnew,Ynew) :- at(X,Y), orient(0), Xnew is X+1, Ynew is Y.
		locForward(Xnew,Ynew) :- at(X,Y), orient(1), Xnew is X, Ynew is Y+1.
		locForward(Xnew,Ynew) :- at(X,Y), orient(2), Xnew is X-1, Ynew is Y.
		locForward(Xnew,Ynew) :- at(X,Y), orient(3), Xnew is X, Ynew is Y-1.

		%% findout if noRight
		noRight :- locRightForward(X,Y), wall(X,Y).
		noRight :- locRightForward(X,Y), wumpusAt(X,Y).
		noRight :- locRightForward(X,Y), posWumpusAt(X,Y).
		noRight :- locRightForward(X,Y), pitAt(X,Y).
		noRight :- locRightForward(X,Y), beenthere(X,Y), locLeftForward(A,B), posExplore(A,B).
		noRight :- locRightForward(X,Y), beenthere(X,Y), loc180Forward(A,B), posExplore(A,B).
		noRight :- locRightForward(X,Y), beenthere(X,Y), locForward(A,B), posExplore(A,B).

		%% findout if noForward
		noForward :- locForward(X,Y), wall(X,Y).
		noForward :- locForward(X,Y), wumpusAt(X,Y).
		noForward :- locForward(X,Y), posWumpusAt(X,Y).
		noForward :- locForward(X,Y), pitAt(X,Y).		
		noForward :- locForward(X,Y), beenthere(X,Y), locLeftForward(A,B), posExplore(A,B).
		noForward :- locForward(X,Y), beenthere(X,Y), loc180Forward(A,B), posExplore(A,B).
		noForward :- locForward(X,Y), beenthere(X,Y), locRightForward(A,B), posExplore(A,B).


		% Orientation rules for turing left		
		orientle(1) :- orient(0).
		orientle(2) :- orient(1).
		orientle(3) :- orient(2).
		orientle(0) :- orient(3).

		% Rules for turning right
		orientri(3) :- orient(0).
		orientri(2) :- orient(3).
		orientri(1) :- orient(2).
		orientri(0) :- orient(1).

		% Location updates depending on orientation (when stepping forward)
		step(1,0) :- orient(0).
		step(0,1) :- orient(1).
		step(-1,0) :- orient(2).
		step(0,-1) :- orient(3).

		% determine if agent is at gold/breezy/smell
		goldAtcurrent :- at(X,Y), goldAt(X,Y).
		smellAtcurrent :- at(X,Y), smellyAt(X,Y).
		breezeAtcurrent :- at(X,Y), breezyAt(X,Y).

		% determine if agent is capable of grabbing/climbing
		readyToExit :- at(0,0), hasgold.
		readyToGrab :- goldAtcurrent, not(hasgold).

		% determine possile locations wumpus
		posWumpusAt(Xnew,Y):- smellyAt(X,Y), wumpusisalive, Xnew is X+1, not(noWumpusAt(Xnew,Y)), not(wumpusAt(A,B)).
		posWumpusAt(Xnew,Y):- smellyAt(X,Y), wumpusisalive, Xnew is X-1, not(noWumpusAt(Xnew,Y)), not(wumpusAt(A,B)).
		posWumpusAt(X,Ynew):- smellyAt(X,Y), wumpusisalive, Ynew is Y - 1, not(noWumpusAt(X,Ynew)), not(wumpusAt(A,B)).
		posWumpusAt(X,Ynew):- smellyAt(X,Y), wumpusisalive, Ynew is Y + 1, not(noWumpusAt(X,Ynew)), not(wumpusAt(A,B)).

		% determine impossible places for wumpus to be
		noWumpusAt(Xnew,Y):- beenthere(X,Y), not(smellyAt(X,Y)), Xnew is X+1.
		noWumpusAt(Xnew,Y):- beenthere(X,Y), not(smellyAt(X,Y)), Xnew is X-1.
		noWumpusAt(X,Ynew):- beenthere(X,Y), not(smellyAt(X,Y)), Ynew is Y - 1.
		noWumpusAt(X,Ynew):- beenthere(X,Y), not(smellyAt(X,Y)),Ynew is Y + 1. 
		noWumpusAt(X,Y):- beenthere(X,Y), not(smellyAt(X,Y)).


		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		%% By knowing  of 2 smelly places, and one not smelly place (if in the right
		%%  relative orientation, one can determine sure places where the Wumpus is) 

		wumpusAt(X2,Y2) :- smellyAt(X,Y), wumpusisalive, X1 is X + 1, Y1 is Y +1, smellyAt(X1,Y1), X2 is X, Y2 is Y+1,
			X3 is X+1,Y3 is Y-1, beenthere(X3,Y3), not(smellyAt(X3,Y3)).
		wumpusAt(X2,Y2) :- smellyAt(X,Y), wumpusisalive, X1 is X + 1, Y1 is Y +1, smellyAt(X1,Y1), X2 is X, Y2 is Y+1,
			X3 is X+2,Y3 is Y, beenthere(X3,Y3), not(smellyAt(X3,Y3)).
		
		wumpusAt(X2,Y2) :- smellyAt(X,Y), wumpusisalive, X1 is X - 1, Y1 is Y +1, smellyAt(X1,Y1), X2 is X -1, Y2 is Y,
			X3 is X,Y3 is Y+2, beenthere(X3,Y3), not(smellyAt(X3,Y3)).
		wumpusAt(X2,Y2) :- smellyAt(X,Y), wumpusisalive, X1 is X - 1, Y1 is Y +1, smellyAt(X1,Y1), X2 is X -1, Y2 is Y,
			X3 is X+1,Y3 is Y+1, beenthere(X3,Y3), not(smellyAt(X3,Y3)).

		wumpusAt(X2,Y2) :- smellyAt(X,Y), wumpusisalive, X1 is X - 1, Y1 is Y -1, smellyAt(X1,Y1), X2 is X, Y2 is Y-1,
			X3 is X-1,Y3 is Y+1, beenthere(X3,Y3), not(smellyAt(X3,Y3)).
		wumpusAt(X2,Y2) :- smellyAt(X,Y), wumpusisalive, X1 is X - 1, Y1 is Y -1, smellyAt(X1,Y1), X2 is X, Y2 is Y-1,
			X3 is X-2,Y3 is Y, beenthere(X3,Y3), not(smellyAt(X3,Y3)).
		
		wumpusAt(X2,Y2) :- smellyAt(X,Y), wumpusisalive, X1 is X + 1, Y1 is Y -1, smellyAt(X1,Y1), X2 is X +1, Y2 is Y,
			X3 is X-1,Y3 is Y-1, beenthere(X3,Y3), not(smellyAt(X3,Y3)).
		wumpusAt(X2,Y2) :- smellyAt(X,Y), wumpusisalive, X1 is X + 1, Y1 is Y -1, smellyAt(X1,Y1), X2 is X +1, Y2 is Y,
			X3 is X,Y3 is Y-2, beenthere(X3,Y3), not(smellyAt(X3,Y3)).
		
		wumpusAt(X2,Y2) :- smellyAt(X,Y), wumpusisalive, X1 is X, Y1 is Y +2, smellyAt(X1,Y1), X2 is X, Y2 is Y+1.
		wumpusAt(X2,Y2) :- smellyAt(X,Y), wumpusisalive, X1 is X+2, Y1 is Y, smellyAt(X1,Y1), X2 is X+1, Y2 is Y.
		

		% determine possile locations Pit
		pitAt(Xnew,Y):- breezyAt(X,Y), Xnew is X+1, not(noPitAt(Xnew,Y)).
		pitAt(Xnew,Y):- breezyAt(X,Y), Xnew is X-1, not(noPitAt(Xnew,Y)).
		pitAt(X,Ynew):- breezyAt(X,Y), Ynew is Y - 1, not(noPitAt(X,Ynew)).
		pitAt(X,Ynew):- breezyAt(X,Y), Ynew is Y + 1, not(noPitAt(X,Ynew)).

		% impossible locations pit
		noPitAt(Xnew,Y):- beenthere(X,Y), not(breezyAt(X,Y)), Xnew is X+1.
		noPitAt(Xnew,Y):- beenthere(X,Y), not(breezyAt(X,Y)), Xnew is X-1.
		noPitAt(X,Ynew):- beenthere(X,Y), not(breezyAt(X,Y)), Ynew is Y - 1.
		noPitAt(X,Ynew):- beenthere(X,Y), not(breezyAt(X,Y)), Ynew is Y + 1.
		noPitAt(X,Y):- beenthere(X,Y), not(breezyAt(X,Y)).
		noPitAt(X,Y):- wall(X,Y).

		% Determine the heuristic equation
		% Determine the distance 
		distance([X,Y],[A,B],D) :-
			at(X,Y),
			posExplore(A,B),
			D is abs(X-A) + abs(Y-B).
			
		% Determine minimum distance
		notMiniDistance(G) :-
			distance([X,Y],[A,B],D),
			distance([C,H],[E,F],G),
			D<G.
		miniDistance([[X,Y],[A,B],D]) :-
			distance([X,Y],[A,B],D),
			not(notMiniDistance(D)).

		% see if any posExplore are close
		nearbyExplore:- distance([X,Y],[A,B],1).
		nearbyExplore:- distance([X,Y],[A,B],2).
		% nearbyExplore:- distance([X,Y],[A,B],3).
		% nearbyExplore:- distance([X,Y],[A,B],4).
		

		% see if currently next to tile (A,B)
		nexto(A,B) :- at(X,Y), C is X+1, D is Y, A = C, B = D.
		nexto(A,B) :- at(X,Y), C is X-1, D is Y, A = C, B = D. 
		nexto(A,B) :- at(X,Y), C is X, D is Y+1, A = C, B = D.
		nexto(A,B) :- at(X,Y), C is X, D is Y-1, A = C, B = D.
	}

	beliefs{
		hasarrow.
		wumpusisalive.
		
		% Keep track of time
		clock(0).
		
		% Starting location
		at(0,0).
		
		% Starting orientation
		orient(0).
		beenthere(0,0).
		actionToDo(bla).
		actionToDo2(bla2).
	}

	goals{
		hasgold,
		getoutofthiscave.
	}

	program{
		% finding distant posExplore
		if bel(not(readyToExit),not(hasgold), not(readyToGrab), not(nearbyExplore), not(gotoExplore(A,B))) then setStuck.
		if bel(not(readyToExit),not(hasgold), not(readyToGrab), gotoExplore(A,B), isStuck , nexto(A,B), readyToExplo) then noStuck.
		if bel(not(readyToExit),not(hasgold), not(readyToGrab), gotoExplore(A,B), isStuck, not(nexto(A,B)), readyToExplo, actionToDo2(forward)) then forward.
		if bel(not(readyToExit),not(hasgold), not(readyToGrab), gotoExplore(A,B), isStuck, not(nexto(A,B)), readyToExplo, actionToDo2(left)) then turn(left).
		if bel(not(readyToExit),not(hasgold), not(readyToGrab), gotoExplore(A,B), isStuck, not(nexto(A,B)), readyToExplo, actionToDo2(right)) then turn(right).
		if bel(not(readyToExit),not(hasgold), not(readyToGrab), gotoExplore(A,B), isStuck, not(readyToExplo), not(at(A,B))) then findExplore.
		if bel(not(readyToExit),not(hasgold), not(readyToGrab), gotoExplore(A,B), isStuck, not(readyToExplo), at(A,B)) then noStuck2.
		
		% if going right if allowed, otherwise turn left then forward
		if bel(not(gotoExplore(A,B)),not(readyToExit), not(readyToGrab), not(justForwardMove), not(noForward), not(hasgold)) then forward.
		if bel(not(gotoExplore(A,B)),not(readyToExit), not(readyToGrab), not(justForwardMove), noForward, not(hasgold)) then turn(left).
		if bel(not(gotoExplore(A,B)),not(readyToExit), not(readyToGrab), justForwardMove, not(noRight), not(hasgold)) then turn(right).
		if bel(not(gotoExplore(A,B)),not(readyToExit), not(readyToGrab), justForwardMove, noRight, not(hasgold)) then turnNoRight.
		
		% going to exit
		if bel(not(readyToExit), not(readyToGrab), hasgold, readyToMove,actionToDo(forward)) then forward.
		if bel(not(readyToExit), not(readyToGrab), hasgold, readyToMove,actionToDo(left)) then turn(left).
		if bel(not(readyToExit), not(readyToGrab), hasgold, readyToMove,actionToDo(right)) then turn(right).
		if bel(not(readyToExit), not(readyToGrab), hasgold, not(readyToMove))then findExit.

		% actions for updating believebase, only after moving forward
		if bel(justforward, smell, not(bump), not(breeze), not(gold)) then setSmell.
		if bel(justforward, breeze, not(bump), not(smell), not(gold)) then setBreeze.
		if bel(justforward, gold, not(bump), not(smell), not(breeze)) then setGoldAt.
		if bel(justforward, smell, not(bump), breeze, not(gold)) then setSmellBreeze.
		if bel(justforward, smell, not(bump), breeze, gold) then setSmellBreezeGold.
		if bel(justforward, smell, not(bump), not(breeze), gold) then setSmellGold.
		if bel(justforward, not(smell), not(bump), breeze, gold) then setBreezeGold.
		% default: path is clear
		if bel(justforward, not(gold), not(smell), not(breeze), not(bump)) then setGroundAt.
		% Recover from bump:
		if bel(bump) then recover.

		if bel(goldAtcurrent, not(hasgold)) then grab.
		if bel(at(0,0), hasgold) then climb.
		%shoot wumpus when certain its at the location in front
		if bel(locForward(X,Y), wumpusAt(X,Y)) then shoot.
		

	}

	actionspec{
		forward {
			pre{
				not(justforward),
				% No previous bump
				not(bump),
				% Get current time, increment
				clock(Time), At is Time + 1,
				% Get current location and step direction
				at(X,Y), step(Xstep, Ystep),
				% Calculate new location
				Xnew is X + Xstep, Ynew is Y + Ystep,
				dontKillYourself(Xnew, Ynew)
			}
			post{
				% Set clock to new time
				clock(At), not(clock(Time)),
				% Update new location
				at(Xnew, Ynew), not(at(X,Y)),
				justforward,
				not(gold), not(breeze), not(smell),
				not(readyToMove),
				not(readyToExplo)
			}
		}
		turn(left) {
			pre{
				% No previous bump
				not(bump),
				clock(Time), At is Time + 1 ,
				% Get current orientation and the new orientation
				orient(Or), orientle(Ornew),
				not(justforward)
			}
			post{
				% Update the clock
				clock(At), not(clock(Time)),
				% Update the orientation
				orient(Ornew), not(orient(Or)),
				not(readyToMove),
				not(readyToExplo)
			}
		}
		turn (right){
			pre{
				% No previous bump
				not(bump),
				clock(Time), At is Time + 1,
				orient(Orr), orientri(Ornewr),
				not(justforward)
			}
			post{
				clock(At), not(clock(Time)),
				orient(Ornewr), not(orient(Orr)),
				not(justForwardMove),
				not(readyToMove),
				not(readyToExplo)
			}
		}
		turnNoRight {
			pre{true}
			post{
				not(justForwardMove)
			}
		}
		% Updates the current location to proper location after bumping into wall
		recover{
			pre{
				% Must have bumped
				bump,
				at(Xr, Yr), step(Xrec, Yrec),
				% New location for step back
				Xrnew is Xr - Xrec, Yrnew is Yr - Yrec
			}
			post{
				not(at(Xr,Yr)), at(Xrnew, Yrnew),
				% Mark wall. NOTE: GOAL crashes if this line is moved up
				wall(Xr,Yr),
				% Clear bump
				not(bump),
				not(justforward)
			}
		}
		setSmell {
			pre{ at(X,Y) }
			post{ smellyAt(X,Y), not(justforward), not(smell), beenthere(X,Y), justForwardMove }
		}
		setBreeze {
			pre{ at(X,Y) }
			post{ breezyAt(X,Y), not(justforward), not(breeze), beenthere(X,Y), justForwardMove }
		}
		setGoldAt {
			pre{ at(X,Y) }
			post{ goldAt(X,Y), not(justforward), beenthere(X,Y), justForwardMove }
		}
		setSmellBreeze{
			pre{ at(X,Y)}
			post{ smellyAt(X,Y), breezyAt(X,Y), not(justforward), beenthere(X,Y), not(breeze), not(smell), justforwardMove}
		}
		setSmellGold{
			pre{ at(X,Y) }
			post{ smellyAt(X,Y), goldAt(X,Y), not(justforward), beenthere(X,Y), not(smell), justforwardMove}
		}
		setBreezeGold{
			pre{ at(X,Y) }
			post{ breezyAt(X,Y), goldAt(X,Y), not(justforward), beenthere(X,Y), not(breeze), justforwardMove}
		}
		setSmellBreezeGold{
			pre{ at(X,Y) }
			post{ smellyAt(X,Y), goldAt(X,Y), breezyAt(X,Y), not(justforward), beenthere(X,Y), not(smell), not(breeze), justforwardMove}
		}

		setGroundAt {
			pre{ at(X,Y) }
			post{ not(justforward), groundAt(X,Y), beenthere(X,Y), justForwardMove }
		}
		grab {
			pre{ at(X,Y), goldAt(X,Y) }
			post{hasgold, not(goldAt(X,Y)), groundAt(X,Y), not(gold)}
		}
		climb {
			pre{ at(0,0), hasgold }
			post{getoutofthiscave, not(at(0,0))}
		}
		setStuck {
			pre{ miniDistance([[Xt,Yt],[At,Bt],Dt]) }
			post{ isStuck, gotoExplore(At,Bt) }
		}
		noStuck {
			pre{ true, nexto(A,B) }
			post{ not(isStuck), not(gotoExplore(A,B)) }
		}
		findExit{
			pre{ actionToDo(Y), shortestPathTo(0,0,X),!}
			post{ actionToDo(X),not(actionToDo(Y)), readyToMove }
		}
		findExplore{
			pre{ actionToDo2(Yhelp), gotoExplore(Xco,Yco), shortestPathTo(Xco,Yco,Action),! }
			post{ actionToDo2(Action), not(actionToDo2(Yhelp)), readyToExplo }
		}
		noStuck2 {
			pre{ true, at(A,B) }
			post{ not(isStuck), not(gotoExplore(A,B)) }
		}
		shoot {
			pre{true}
			%No special preconditions. Arrow lost after shot   
			post{ not(hasarrow) , not(wumpusisalive) }
		}

	}	
}


======================== PERCEPT RULES =========================================

perceptrules{
		when input{ percept([breeze,_,_,_,_],T) } do update{ breeze }.
		when input{ percept([_,stench,_,_,_],T) } do update{ smell }.
		when input{ percept([_,_,bump,_,_],T) } do update{ bump }.
		when input{ percept([_,_,_,scream,_],T) } do update{ not(wumpusisalive) }.
		when input{ percept([_,_,_,_,glitter],T) } do update{ gold }.
}



============================ SLICING RESULTS ===================================


if this.bel(locForward(X,Y) , wumpusAt(X,Y)) then shoot.

[SLICER] retained 26 of 27 rules

Functors: {wumpusAt, at}