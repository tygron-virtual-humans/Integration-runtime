main: wumpusAgent
{
	knowledge{

		%%% SHORTEST PATH %%%
		% Calculates the shortest path from the current location to the location defined in Pos, and returns the next step of this path.
		shortestPathTo(Pos,B) :- position(X,Y), shortestPathPlanner([X,Y],Pos,Path1), reverse(Path1,Path2), Path2 = [A|[B|C]].
		shortestPathPlanner(From,To,Path) :- waves(To,[[From],[]],Waves), path(From,To,Waves,Path).
		waves(To,[Wave|Waves],Waves) :- member(To,Wave), !.
		waves(To,[Wave,LastWave|LastWaves],Waves) :- next_wave(Wave,LastWave,NextWave),	waves(To,[NextWave,Wave,LastWave|LastWaves],Waves).
		next_wave(Wave,LastWave,NextWave) :- setof(X,admissible(X,Wave,LastWave),NextWave).
		admissible(X,Wave,LastWave) :- walkable(X), neighbor(X,Wave), not(member(X,LastWave)), not(member(X,Wave)).
		walkable([X,Y]) :- clear(X,Y); smelly(X,Y); breezy(X,Y); unvisited(X,Y).
		neighbor(Pos,Wave) :- member(Pos1,Wave), adjacent(Pos,Pos1), position(X,Y).
		adjacent([X1,Y],[X2,Y]) :- next_to(X1,X2).
		adjacent([X,Y1],[X,Y2]) :- next_to(Y1,Y2).
		next_to(A,B) :- is(A,+(B,1)).
		next_to(A,B) :- is(A,-(B,1)).
		path(Pos,Pos,Waves,[Pos]) :- !.
		path(Pos1,Pos2,[Wave|Waves],[Pos2|Path]) :- member(Pos,Wave), adjacent(Pos,Pos2), !, path(Pos1,Pos,Waves,Path).

		%%% NEAREST UNVISITED %%%
		% Calculates the unvisited locations that are most near to the current position, and returns these as X, Y coordinates.
		nearUnvisited(X,Y) :- minimumDistance(M), position(I,J), unvisited(X,Y), Dxtemp is I-X, Dytemp is J-Y, Dx is abs(Dxtemp), Dy is abs(Dytemp), D is Dx+Dy, D = M.
		distances(D) :- position(I,J), unvisited(X,Y), Dxtemp is I-X, Dytemp is J-Y, Dx is abs(Dxtemp), Dy is abs(Dytemp), D is Dx+Dy.
		distanceList(L) :- setof(X,distances(X),L).
		minimumDistance(M) :- distanceList(D), sort(D,Ds), Ds = [M|B].

		%%% WUMPUS DETECTION %%%
		% Determines the location of the wumpus if enough data about stenches and safe locations is present.
		wumpusAt(A,B) :- smelly(X,Y), Xnew is X+2, smelly(Xnew,Y), A is X+1, B is Y.
		wumpusAt(A,B) :- smelly(X,Y), Ynew is Y+2, smelly(X,Ynew), A is X, B is Y+1.
		wumpusAt(A,B) :- smelly(X,Y), Xnew is X-1, Ynew is Y-1, smelly(Xnew, Ynew), isSafe(Xnew,Y), A is X, B is Ynew.
		wumpusAt(A,B) :- smelly(X,Y), Xnew is X-1, Ynew is Y-1, smelly(Xnew, Ynew), isSafe(X,Ynew), A is Xnew, B is Y.
		wumpusAt(A,B) :- smelly(X,Y), Xnew is X-1, Ynew is Y+1, smelly(Xnew, Ynew), isSafe(Xnew,Y), A is X, B is Ynew.
		wumpusAt(A,B) :- smelly(X,Y), Xnew is X-1, Ynew is Y+1, smelly(Xnew, Ynew), isSafe(X,Ynew), A is Xnew, B is Y.
		wumpusAt(A,B) :- smelly(X,Y), Xpos is X+1, Xneg is X-1, Ypos is Y+1, Yneg is Y-1, isSafe(Xpos,Y), isSafe(Xneg,Y), isSafe(X,Ypos), A is X, B is Yneg.
		wumpusAt(A,B) :- smelly(X,Y), Xpos is X+1, Xneg is X-1, Ypos is Y+1, Yneg is Y-1, isSafe(Xpos,Y), isSafe(Xneg,Y), isSafe(X,Yneg), A is X, B is Ypos.
		wumpusAt(A,B) :- smelly(X,Y), Xpos is X+1, Xneg is X-1, Ypos is Y+1, Yneg is Y-1, isSafe(X,Ypos), isSafe(X,Yneg), isSafe(Xneg,Y), A is Xpos, B is Y.
		wumpusAt(A,B) :- smelly(X,Y), Xpos is X+1, Xneg is X-1, Ypos is Y+1, Yneg is Y-1, isSafe(X,Ypos), isSafe(X,Yneg), isSafe(Xpos,Y), A is Xneg, B is Y.
		isSafe(X,Y) :- visited(X,Y); unvisited(X,Y).

		%%% SAFETY DETECTION %%%
		% If a stench and a breeze have manhatten-distance 2, the position between them is safe to if there are no stenches and breezes overlapping.
		% This in-between position is by not marked as unvisited however by the percept rules.
		% safePosition determines this positions, so that they can be marked as unvisited.
		safePosition(Xsafe,Y) :- smelly(X,Y), Xnew is X+1, Ynew is Y+1, breezy(Xnew,Ynew), not(breezy(X,Y)), not(smelly(Xnew,Ynew)), Xsafe is X+1.
		safePosition(X,Ysafe) :- smelly(X,Y), Xnew is X+1, Ynew is Y+1, breezy(Xnew,Ynew), not(breezy(X,Y)), not(smelly(Xnew,Ynew)), Ysafe is Y+1.
		safePosition(Xsafe,Y) :- smelly(X,Y), Xnew is X+1, Ynew is Y-1, breezy(Xnew,Ynew), not(breezy(X,Y)), not(smelly(Xnew,Ynew)), Xsafe is X+1.
		safePosition(X,Ysafe) :- smelly(X,Y), Xnew is X+1, Ynew is Y-1, breezy(Xnew,Ynew), not(breezy(X,Y)), not(smelly(Xnew,Ynew)), Ysafe is Y-1.
		safePosition(Xsafe,Y) :- smelly(X,Y), Xnew is X+2, breezy(Xnew,Y), not(breezy(X,Y)), not(smelly(Xnew,Y)), Xsafe is X+1.
		safePosition(X,Ysafe) :- smelly(X,Y), Ynew is Y+2, breezy(X,Ynew), not(breezy(X,Y)), not(smelly(X,Ynew)), Ysafe is Y+1.
		safePosition(Xsafe,Y) :- smelly(X,Y), Xnew is X-2, breezy(Xnew,Y), not(breezy(X,Y)), not(smelly(Xnew,Y)), Xsafe is X-1.
		safePosition(X,Ysafe) :- smelly(X,Y), Ynew is Y-2, breezy(X,Ynew), not(breezy(X,Y)), not(smelly(X,Ynew)), Ysafe is Y-1.
		safePosition(Xsafe,Y) :- smelly(X,Y), Xnew is X-1, Ynew is Y+1, breezy(Xnew,Ynew), not(breezy(X,Y)), not(smelly(Xnew,Ynew)), Xsafe is X-1.
		safePosition(X,Ysafe) :- smelly(X,Y), Xnew is X-1, Ynew is Y+1, breezy(Xnew,Ynew), not(breezy(X,Y)), not(smelly(Xnew,Ynew)), Ysafe is Y+1.
		safePosition(Xsafe,Y) :- smelly(X,Y), Xnew is X-1, Ynew is Y-1, breezy(Xnew,Ynew), not(breezy(X,Y)), not(smelly(Xnew,Ynew)), Xsafe is X-1.
		safePosition(X,Ysafe) :- smelly(X,Y), Xnew is X-1, Ynew is Y-1, breezy(Xnew,Ynew), not(breezy(X,Y)), not(smelly(Xnew,Ynew)), Ysafe is Y-1.
		
	}

	beliefs{
		hasarrow.					% The agent has an arrow initially.
		wumpusisalive.				% The wumpus is alive initially.
		time(0).						% The agent starts at time-instance 0.
		orientation(east).		% Initial orientation
		position(0,0).				% Initial positions; could have been anything in principle, but (0,0) is most logical.
		visited(0,0).				% Initial positions is - naturally - visited.
		breezy(x,y).				% This is a hack. There were problems with using the predicate breezy(X,Y) in the walkable([X,Y]) knowledge function otherwise.
	}

	goals{
		hasgold,						% The agent is in this cave to obtain gold, and...
		getoutofthiscave.			% ...escape the cave as soon as he gets it!
	}

	program{

		%%% ADAPTING GOALS %%%
		% Rules for the adaptation of gold:
		% 	First one for going to an unvisited position if the gold is not yet obtained or located.
		% 	Second and fourth one for escaping the cave as soons as no more unvisited positions are available.
		% 	Third one for escaping the cave if the agent has obtained the gold.
		% 	Fifth one for hunting down the wumpus as soon as it's locations is determined and the gold is not yet obtained or located.
		% 	Sixth one for killing the wumpus if the distance between the wumpus and the agent is equal to 1 and the gold is not yet obtained or located.
		if not(goal(position(A,B))), not(bel(wumpus(I,J))), bel(nearUnvisited(X,Y)), not(bel(gold(C,D))), not(bel(hasgold)) then adopt(position(X,Y)).
		if not(goal(position(A,B))), not(bel(wumpus(I,J))), not(bel(unvisited(X,Y))), not(bel(gold(C,D))), not(bel(hasgold)) then adopt(position(0,0)).
		if not(goal(position(A,B))), bel(hasgold) then adopt(position(0,0)).
		if not(goal(position(A,B))), not(bel(wumpus(I,J))), not(bel(unvisited(X,Y))), not(bel(hasgold)), not(bel(position(0,0))) then adopt(position(0,0)).
		if not(goal(position(A,B))), not(goal(slaywumpus)), bel(wumpus(X,Y), smelly(I,J)), not(bel(gold(C,D))), not(bel(hasgold)) then adopt(position(I,J)).	
		if not(bel(gold(C,D))), not(bel(hasgold)), not(goal(slaywumpus)), not(goal(position(I,J))), bel(wumpus(X,Y), position(A,B), smelly(A,B)) then adopt(slaywumpus).
	
		%%% MOVING %%%
		% Rules for moving in a particular direction when the agent has the goal of reaching a certain position.
		if goal(position(I,J)), bel(shortestPathTo([I,J],[A,B]), position(X,Y), is(A,+(X,1)), orientation(east)) then forward.
		if goal(position(I,J)), bel(shortestPathTo([I,J],[A,B]), position(X,Y), is(A,+(X,1)), (orientation(south); orientation(west))) then turn(left).
		if goal(position(I,J)), bel(shortestPathTo([I,J],[A,B]), position(X,Y), is(A,+(X,1)), orientation(north)) then turn(right).
		if goal(position(I,J)), bel(shortestPathTo([I,J],[A,B]), position(X,Y), is(A,-(X,1)), orientation(west)) then forward.
		if goal(position(I,J)), bel(shortestPathTo([I,J],[A,B]), position(X,Y), is(A,-(X,1)), (orientation(north); orientation(east))) then turn(left).
		if goal(position(I,J)), bel(shortestPathTo([I,J],[A,B]), position(X,Y), is(A,-(X,1)), orientation(south)) then turn(right).
		if goal(position(I,J)), bel(shortestPathTo([I,J],[A,B]), position(X,Y), is(B,+(Y,1)), orientation(north)) then forward.
		if goal(position(I,J)), bel(shortestPathTo([I,J],[A,B]), position(X,Y), is(B,+(Y,1)), (orientation(east); orientation(south))) then turn(left).
		if goal(position(I,J)), bel(shortestPathTo([I,J],[A,B]), position(X,Y), is(B,+(Y,1)), orientation(west)) then turn(right).
		if goal(position(I,J)), bel(shortestPathTo([I,J],[A,B]), position(X,Y), is(B,-(Y,1)), orientation(south)) then forward.
		if goal(position(I,J)), bel(shortestPathTo([I,J],[A,B]), position(X,Y), is(B,-(Y,1)), (orientation(west); orientation(north))) then turn(left).
		if goal(position(I,J)), bel(shortestPathTo([I,J],[A,B]), position(X,Y), is(B,-(Y,1)), orientation(east)) then turn(right).

		%%% SLAYING THE WUMPUS %%%
		% Rules for slaying the wumpus when the agent is at distance 1 from te wumpus.
		if goal(slaywumpus), bel(wumpus(X,Y), Xnew is X-1, position(Xnew, Y), orientation(east)) then shoot.
		if goal(slaywumpus), bel(wumpus(X,Y), Xnew is X-1, position(Xnew, Y), (orientation(south); orientation(west))) then turn(left).
		if goal(slaywumpus), bel(wumpus(X,Y), Xnew is X-1, position(Xnew, Y), orientation(north)) then turn(right).
		if goal(slaywumpus), bel(wumpus(X,Y), Xnew is X+1, position(Xnew, Y), orientation(west)) then shoot.
		if goal(slaywumpus), bel(wumpus(X,Y), Xnew is X+1, position(Xnew, Y), (orientation(north); orientation(east))) then turn(left).
		if goal(slaywumpus), bel(wumpus(X,Y), Xnew is X+1, position(Xnew, Y), orientation(south)) then turn(right).
		if goal(slaywumpus), bel(wumpus(X,Y), Ynew is Y-1, position(X, Ynew), orientation(north)) then shoot.
		if goal(slaywumpus), bel(wumpus(X,Y), Ynew is Y-1, position(X, Ynew), (orientation(east); orientation(south))) then turn(left).
		if goal(slaywumpus), bel(wumpus(X,Y), Ynew is Y-1, position(X, Ynew), orientation(west)) then turn(right).
		if goal(slaywumpus), bel(wumpus(X,Y), Ynew is Y+1, position(X, Ynew), orientation(south)) then shoot.
		if goal(slaywumpus), bel(wumpus(X,Y), Ynew is Y+1, position(X, Ynew), (orientation(west); orientation(north))) then turn(left).
		if goal(slaywumpus), bel(wumpus(X,Y), Ynew is Y+1, position(X, Ynew), orientation(east)) then turn(right).
		
		%%% GOLD DIGGING %%%
		% Rule for fetching the gold if the position of the agent equals the position of the gold
		if bel(gold(X,Y), position(X,Y)) then grab.

		%%% ESCAPING %%%
		% Rules for escaping the cave if the initial position is reached and either the agent has the gold or no more unvisited locations to explore.
		if bel(hasgold, position(0,0)) then climb.
		if not(goal(position(A,B))), not(bel(wumpus(I,J))), not(bel(unvisited(X,Y))), not(bel(hasgold)), bel(position(0,0)) then climb.
	}

	actionspec{

		%%% FORWARD %%%
		forward {
			pre{ orientation(east), position(X,Y), Xnew is X+1 }
			post{ not(position(X,Y)), position(Xnew,Y), not(unvisited(Xnew,Y)), visited(Xnew,Y) }
		}
		forward {
			pre{ orientation(west), position(X,Y), Xnew is X-1 }
			post{ not(position(X,Y)), position(Xnew, Y), not(unvisited(Xnew,Y)), visited(Xnew,Y) }
		}
		forward {
			pre{ orientation(north), position(X,Y), Ynew is Y+1 }
			post{ not(position(X,Y)), position(X,Ynew), not(unvisited(X,Ynew)), visited(X,Ynew) }
		}
		forward {
			pre{ orientation(south), position(X,Y), Ynew is Y-1 }
			post{ not(position(X,Y)), position(X,Ynew), not(unvisited(X,Ynew)), visited(X,Ynew) }
		}

		%%% TURN(LEFT) %%%
		turn(left) {
			pre{ orientation(east) }
			post{ not(orientation(east)), orientation(north) }
		}
		turn(left) {
			pre{ orientation(north) }
			post{ not(orientation(north)), orientation(west) }
		}
		turn(left) {
			pre{ orientation(west) }
			post{ not(orientation(west)), orientation(south) }
		}
		turn(left) {
			pre{ orientation(south) }
			post{ not(orientation(south)), orientation(east) }
		}

		%%% TURN(RIGHT) %%%
		turn(right) {
			pre{ orientation(east) }
			post{ not(orientation(east)), orientation(south) }
		}
		turn(right) {
			pre{ orientation(south) }
			post{ not(orientation(south)), orientation(west) }
		}
		turn(right) {
			pre{ orientation(west) }
			post{ not(orientation(west)), orientation(north) }
		}
		turn(right) {
			pre{ orientation(north) }
			post{ not(orientation(north)), orientation(east) }
		}
		
		%%% GRAB %%%
		grab {
			pre{ position(X,Y), gold(X,Y) }
			post{ hasgold, not(gold(X,Y)) }
		}
		
		%%% CLIMB %%%
		climb {
			pre{ position(0,0) }
			post{ getoutofthiscave }
		}

		%%% SHOOT %%%
		shoot {
			pre{ wumpusisalive, hasarrow }
			post{ not(wumpusisalive), not(hasarrow), slaywumpus }
		}
	}

}

======================== PERCEPT RULES =========================================

perceptrules{

		%%% TIME %%%
		% Rule to update the current time
		when input{ percept([_,_,_,_,_], T), time(Told) } do update{ not(time(Told)), time(T) }.

		%%% PIT %%%
		% Rule to add a breeze if one is encountered
		when input{ percept([breeze,_,null,_,_], T), position(X,Y)} do update{ breezy(X,Y) }.
		
		%%% STENCH %%%
		% Rules to add a smelly if one is encountered (first rule) or a clear if a smelly is encountered, but the wumpus is already dead (second rule).
		% In the latter case, four unvisited locations are added as well.
		when input{ percept([_,stench,null,_,_], T), position(X,Y), wumpusisalive} do update{ smelly(X,Y) }.
		when input{ percept([null,stench,null,_,_], T), position(X,Y), not(wumpusisalive), Xe is X+1, Xw is X-1, Yn is Y+1, Ys is Y-1 } do update{ clear(X,Y), unvisited(Xw,Y), unvisited(Xe,Y), unvisited(X,Yn), unvisited(X,Ys) }.

		%%% WALL %%%
		% Rules to add a wall if one is encountered, and move the agent back to a former position.
		when input{ percept([_,_,bump,_,_], T), orientation(east), position(X,Y), Xold is X-1 } do update{ wall(X,Y), not(position(X,Y)), position(Xold,Y) }.
		when input{ percept([_,_,bump,_,_], T), orientation(north), position(X,Y), Yold is Y-1 } do update{ wall(X,Y), not(position(X,Y)), position(X,Yold) }.
		when input{ percept([_,_,bump,_,_], T), orientation(west), position(X,Y), Xold is X+1 } do update{ wall(X,Y), not(position(X,Y)), position(Xold,Y) }.
		when input{ percept([_,_,bump,_,_], T), orientation(south), position(X,Y), Yold is Y+1 } do update{ wall(X,Y), not(position(X,Y)), position(X,Yold) }.

		%%% SCREAM %%%
		% Rule to remove the wumpus from the believebase, because he is... dead!
		when input{ percept([_,_,_,scream,_], T), wumpus(A,B)} do update{ not(wumpus(A,B))}.		

		%%% GOLD %%%
		% Rule to add the location of the gold, if the gold is encountered.
		when input{ percept([_,_,_,_,glitter], T), position(X,Y)} do update{ gold(X,Y) }.

		%%% CLEAR %%%
		% Rules to add a clear if no breeze, stench or wall is encountered, and subsequently add four related unvisited locations.
		% Also, additional unvisited locations are added for conflicting stenches and breezes (second rule).
		% The third rule deletes the unvisited locations that are previously visited.
		when input{ percept([null,null,null,_,_], T), position(X,Y), Xe is X+1, Xw is X-1, Yn is Y+1, Ys is Y-1} do update{ clear(X,Y), unvisited(Xw,Y), unvisited(Xe,Y), unvisited(X,Yn), unvisited(X,Ys) }.
		when input{ safePosition(X,Y) } do update { unvisited(X,Y) }.
		when input{ visited(X,Y) } do update { not(unvisited(X,Y)) }.
		
		%%% WUMPUS %%%	
		% Rule to derive the location of the wumpus if he is still alive.
		when input{ wumpusAt(X,Y), wumpusisalive } do update { wumpus(X,Y) }.
	}

	
============================ SLICING RESULTS ===================================

if this.bel(hasgold , position(0,0)) then climb.
if not(this.goal(position(A,B))), not(this.bel(wumpus(I,J))), not(this.bel(unvisited(X,Y))), not(this.bel(hasgold)), this.bel(position(0,0)) then climb.

[SLICER] retained 31 of 33 rules

Functors: {position, wumpusAt}