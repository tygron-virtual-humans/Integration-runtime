in model-checker.maude
in querylanguage2.maude
in additionals.maude
in goal-sem.maude
mod BLOCK-GOAL is
	protecting SYNTACTICAL-DEFS .
	protecting GOAL-PREDS .
	sort Block .
	subsorts GroundTerm < Block .
	vars X Y Z : Block .
	vars BB GB U : BeliefBase .
	vars S : Substitution .
	var LS : ListSubstitution .
	op on : Block Block -> Belief .
	op clear : Block -> Belief .
	op block : Block -> Belief .
	crl [on] : solve1(on(X, Y), U) => sol(top, none) if matches(on(X, Y), U) == none .
	crl [on] : solve1(on(X, Z), U) => sol(top, S) if (S & LS) := allMatches(on(X,Z), U, U) /\ S =/= none .
	crl [clear] : solve1(clear(X), U) => sol(top, none) if matches(clear(X), U) == none .
	crl [clear] : solve1(clear(X), U) => sol(top, S) if (S & LS) := allMatches(clear(X), U, U) /\ S =/= none .
	crl [block] : solve1(block(X), U) => sol(top, none) if matches(block(X), U) == none .
	crl [block] : solve1(block(X), U) => sol(top, S) if (S & LS) := allMatches(block(X), U, U) /\ S =/= none .
	op move : Block Block -> B-Action .
	eq [b-act] : move(X, Z) = [block(Z) , neg on(X,Z) ;; on(X,table) ;; clear(Z)] .
	op moveConditional : Block Block -> C-Action .
	eq [c-act] : moveConditional(X, Z) = {goal(on(ab,table)) /\ bel(on(X,Z)) /\ bel(clear(X))} do(move(X,Z)) .
	op lb2 : -> GMentalState .
	eq [by2] : lb2 = << bLabel(empty), bb, gb  >> .
	ops property : -> Prop .
	ceq << L:Label, BB, GB >> |= property = true if matches(on(ab,table), BB) == none .
	ops aa ab ac ad ae table : -> Block . 
	eq bb = on(aa,table) ; block(aa) ; on(ab,aa) ; block(ab) ; on(ac,ab) ; block(ac) ; on(ad,ac) ; block(ad) ; clear(ad) ; on(ae,table) ; block(ae) ; clear(ae)  .
	op gb : -> GoalBase .
	op g1 : -> BeliefBase .
	eq g1 = on(ab,table) .
	eq gb = g1 .
endm
*** set profile off . set profile on . rew lb2 . show profile . set profile off .
set verbose on .
*** red modelCheck(lb2, <> property) .
rew lb2 .
