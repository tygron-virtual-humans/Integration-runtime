in model-checker.maude
in querylanguage2.maude
in additionals.maude
in goal-sem.maude
mod BLOCK-GOAL is
	protecting SYNTACTICAL-DEFS .
	protecting GOAL-PREDS .
	protecting INT .
	
	*** *** *** SORTS AND VARS *** *** ***
	
	sort Num .
	subsort GroundTerm < Num .

	vars BB BB' GB U G G' : BeliefBase .
	var Q : Query .
	vars S : Substitution .
	var LS : ListSubstitution .
	var INT INT' : Int .
	vars I J : Num .

	*** *** *** ARITHMATIC *** *** ***

	op toNum : Int -> Num .
	ops add sub : Num Num -> Num .
	eq add(toNum(INT), toNum(INT')) = toNum(INT + INT') .
	eq sub(toNum(INT), toNum(INT')) = toNum(INT + - INT') .

	*** *** *** KNOWLEDGE *** *** ***
	
	crl [is] : solve1(is(I, J), U) => sol(top, none) if I == J .
	crl [is] : solve1(is(I, J), U) => sol(bot, none) if I =/= J .
	crl [is] : solve1(is(I, J), U) => sol(top, S) if S := upTerm(I) <- upTerm(J) .

	crl [current] : solve1(current(I), U) => sol(top, none) if matches(current(I), U) == none .
	crl [current] : solve1(current(I), U) => sol(bot, none) if matches(current(I), U) == noMatch .
	crl [current] : solve1(current(I), U) => sol(top, S) if (S & LS) := matches(current(I), U) /\ S =/= none .
	crl [current] : solve1(current(I), U) => sol(top, S) if (S & LS) := allMatches(current(I), U, U) /\ S =/= none .

	crl [current] : solve1(goalCurrent(I), U) => sol(top, none) if matches(goalCurrent(I), U) == none .
	crl [current] : solve1(goalCurrent(I), U) => sol(bot, none) if matches(goalCurrent(I), U) == noMatch .
	crl [current] : solve1(goalCurrent(I), U) => sol(top, S) if (S & LS) := matches(goalCurrent(I), U) /\ S =/= none .
	crl [current] : solve1(goalCurrent(I), U) => sol(top, S) if (S & LS) := allMatches(goalCurrent(I), U, U) /\ S =/= none .

	*** *** *** BELIEFS *** *** ***

	ops dummy foo : -> Belief .
	ops current goalCurrent memory : Num -> Belief .
	ops is : Num Num -> Belief .

	op bb : -> BeliefBase .
	eq bb = current(toNum(0)) ; memory(toNum(0)) .
	
	*** *** *** GOALS *** *** ***

	op gb : -> GoalBase .
	ops g1 : -> BeliefBase .
	eq g1 = foo .
	eq gb = empty .

	*** *** *** PROGRAM 1 : Using beliefs and goals *** *** ***

	op c1 : Num Num -> C-Action .
	eq [c-act] : c1(I, J) = {
		bel(current(J))
	/\	~ goal(current(I))
	} do(adopt(current(add(J, toNum(1))))) .

	op c2 : Num Num -> C-Action .
	eq [c-act] : c2(I, J) = {
		a-goal(current(I))
	/\	bel(is(J, sub(I, toNum(1))))

	*** Program 1a : Forget prior numbers
	} do([top , neg current(J) ;; current(I)]) .

	*** Program 1b : Remember all numbers
	*** } do([top , neg current(J) ;; current(I) ;; memory(I) ]) .

	*** *** *** PROGRAM 2 : Counting using beliefs only *** *** ***

***	op c1 : Num Num -> C-Action .
*** (	eq [c-act] : c1(I, J) = {
		bel(current(J))
	/\	~ bel(goalCurrent(I))
	} do([top , goalCurrent(add(J, toNum(1)))]) . )

***	op c2 : Num Num -> C-Action .
*** (	eq [c-act] : c2(I, J) = {
		bel(goalCurrent(I))
	/\	bel(is(J, sub(I, toNum(1))))
	} do([top , neg current(J) ;; neg goalCurrent(I) ;; current(I)]) . )

	*** *** *** OTHER *** *** ***

	op lb2 : -> GMentalState .
	eq [by2] : lb2 = << bLabel(empty), bb, gb  >> .
	
	op property : Int -> Prop .
	***ceq << L:Label, BB, GB:GoalBase >> |= property(INT) = true if matches(current(toNum(INT)), BB) == none .
	ceq << L:Label, BB, empty >> |= property(INT) = true if matches(current(toNum(INT)), BB) == none .
	ceq << L:Label, BB, GB:GoalBase >> |= property(INT) = true if matches(current(toNum(INT)), BB) == none .

endm
*** set print attribute off .
set verbose on .
*** red modelCheck(lb2, <> property(10)) .
