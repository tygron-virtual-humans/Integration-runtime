/**
 * GOAL interpreter that facilitates developing and executing GOAL multi-agent
 * programs. Copyright (C) 2011 K.V. Hindriks, W. Pasman
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program. If not, see <http://www.gnu.org/licenses/>.
 */

package goal.core.program.validation.agentfile;

import goal.core.kr.language.Expression;
import goal.core.kr.language.Var;
import goal.core.program.ActionSpecification;
import goal.core.program.GOALProgram;
import goal.core.program.Module;
import goal.core.program.Module.TYPE;
import goal.core.program.NameSpace;
import goal.core.program.dependencygraph.DependencyGraph;
import goal.core.program.expressiongraph.ExpressionGraph;
import goal.core.program.expressiongraph.ModuleGraphGenerator;
import goal.core.program.validation.Validator;
import goal.core.program.validation.ValidatorError;
import goal.core.program.validation.ValidatorWarning;

import java.util.HashSet;
import java.util.List;

/**
 * {@link Validator} for a {@link GOALProgram}.<br>
 *
 * Checks for the following errors:
 * <ul>
 * <li>The absence of both the event module and main module.</li>
 * <li>Imported files that do not exist.</li>
 * </ul>
 *
 * Checks for the following warnings:
 * <ul>
 * <li>Defined but unused macros (this is done here so that these warnings do
 * not get printed multiple times)</li>
 * <li>Macros that have unused parameters.</li>
 * <li>Macros that hide definitions of other macros</li>
 * <li>Expressions that are defined but not queried</li>
 * <li>Expressions that are queried, but never defined</li>
 * </ul>
 *
 * Further errors and warnings may be generated by other {@link Validator}s,
 * e.g. {@link ModuleValidator}.
 *
 * @author N.Kraayenbrink
 * @author K.Hindriks
 *
 */
public class GOALProgramValidator extends Validator<Module> {

	@Override
	protected void doValidate(Module subject) {
		// Check that either the main or event module exists.
		// Errors because of duplicate uses of these types of modules are issued
		// by the parser.
		if (!this.mod2g && !subject.hasModuleOfType(TYPE.MAIN)
				&& !subject.hasModuleOfType(TYPE.EVENT)) {
			report(new ValidatorError(GOALError.MUSTHAVE_MAIN_OR_EVENT, subject));
		}

		// Check for any conflicts in name space of user specified actions and
		// user defined modules.
		// Action specifications defined in the <code>init</code> module are
		// globally accessible.
		// All other specifications are only locally accessible within the
		// module in which the action is
		// specified and its child modules.
		// Modules specified at top level are also globally accessible. Child
		// modules are only accessible
		// within the parent module, its sibling modules, and the child modules
		// of the module itself.
		// Conflicts arise if an action specification and a module with exactly
		// the same number of parameters
		// are accessible within any scope (context) simultaneously.
		// Local name space overrides more global name space.

		// Validate the name space.
		// Clone the name space; we are going to use and modify this space but
		// do not want to modify the original name space.
		NameSpace nameSpace = subject.getNameSpace().clone();
		// The name space at the program's top level inherits definitions
		// (action specs, macros, modules) from the
		// <code>init</code> module. Definitions do not override each other.
		if (subject.hasModuleOfType(TYPE.INIT)) {
			nameSpace.inherit(
					subject.getModuleOfType(TYPE.INIT).getNameSpace(), false);
		}

		NameSpaceValidator nameSpaceValidator = new NameSpaceValidator();
		nameSpaceValidator.validate(nameSpace, this.mod2g);
		nameSpaceValidator.reportToSuperior(this);

		// Validate modules recursively.
		for (List<Module> moduleList : subject.getModules().values()) {
			for (Module module : moduleList) {
				// a GOAL agent program does not bind any variables.
				ModuleValidator moduleValidator = new ModuleValidator(
						nameSpace, new HashSet<Var>());
				moduleValidator.validate(module, this.mod2g);
				moduleValidator.reportToSuperior(this);
			}
		}

		if (this.mod2g) {
			return;
		}

		// Check whether all child modules and local action specifications of
		// children have been used.
		for (String childKey : subject.getModules().keySet()) {
			for (Module child : subject.getModules().get(childKey)) {
				if (!child.isUsed()) {
					report(new ValidatorWarning(GOALWarning.MODULE_NEVER_USED,
							child, child.getSignature()));
				}
				for (ActionSpecification actionSpec : child
						.getActionSpecifications()) {
					if (!actionSpec.isUsed()) {
						report(new ValidatorWarning(
								GOALWarning.ACTION_NEVER_USED, actionSpec,
								actionSpec.getSignature()));
					}
				}
			}
		}

		// Validate the agent's knowledge.
		// This is a global check because all knowledge is combined into a
		// single
		// knowledge base accessible at top level. It therefore needs to be
		// performed
		// last, when all UserOrFocusActions have been resolved.
		// Checks whether definitions are unused or queries never defined.
		// validateKnowledge(subject);
		validateKnowledge2(subject);
	}

	/**
	 * TODO: move to validator for knowledge. Checks whether definitions are
	 * used and queries in agent program have been defined.
	 *
	 * @param subject
	 *            A parsed GOAL agent program.
	 */
	public void validateKnowledge(Module subject) {
		// get the expression graph for the given program
		ExpressionGraph graph = new ExpressionGraph.EmptyGraph();
		try {
			ModuleGraphGenerator programGraphGenerator = new ModuleGraphGenerator();
			programGraphGenerator.setKRlanguage(subject.getKRLanguage());
			programGraphGenerator.createGraph(subject, null);
			graph = programGraphGenerator.getGraph();
		} catch (Exception ex) {
		} catch (Error err) {
		}

		// Generate warnings for unused definitions
		for (Expression exp : graph.getUnusedDefinitions()) {
			report(new ValidatorWarning(GOALWarning.EXPRESSION_NEVER_USED, exp,
					exp.toString()));
		}
		// and warnings for undefined queries.
		for (Expression exp : graph.getUndefinedQueries()) {
			report(new ValidatorError(
					GOALError.EXPRESSION_QUERIED_NEVER_DEFINED, exp,
					exp.toString()));
		}
	}

	/**
	 * TODO: move to validator for knowledge. Checks whether definitions are
	 * used and queries in agent program have been defined.
	 *
	 * @param subject
	 *            A parsed GOAL agent program.
	 */
	public void validateKnowledge2(Module subject) {
		// get the expression graph for the given program
		DependencyGraph<?> graph = null;
		try {
			goal.core.program.dependencygraph.ModuleGraphGenerator programGraphGenerator = new goal.core.program.dependencygraph.ModuleGraphGenerator();
			programGraphGenerator.setKRlanguage(subject.getKRLanguage());
			programGraphGenerator.createGraph(subject, null);
			graph = programGraphGenerator.getGraph();
		} catch (Exception ex) {
		} catch (Error err) {
		}

		if (graph != null) {
			// Generate warnings for unused definitions
			for (Expression exp : graph.getUnusedDefinitions()) {
				report(new ValidatorWarning(GOALWarning.EXPRESSION_NEVER_USED,
						exp, exp.toString()));
			}
			// and warnings for undefined queries.
			for (Expression exp : graph.getUndefinedQueries()) {
				report(new ValidatorError(
						GOALError.EXPRESSION_QUERIED_NEVER_DEFINED, exp,
						exp.toString()));
			}
		}
	}
}
