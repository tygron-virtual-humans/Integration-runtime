/**
 * GOAL interpreter that facilitates developing and executing GOAL multi-agent
 * programs. Copyright (C) 2011 K.V. Hindriks, W. Pasman
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program. If not, see <http://www.gnu.org/licenses/>.
 */

package goal.core.program.validation.agentfile;

import goal.core.kr.language.Term;
import goal.core.kr.language.Update;
import goal.core.kr.language.Var;
import goal.core.program.ActionSpecification;
import goal.core.program.Module;
import goal.core.program.Module.TYPE;
import goal.core.program.NameSpace;
import goal.core.program.literals.Macro;
import goal.core.program.literals.MentalStateCond;
import goal.core.program.rules.Rule;
import goal.core.program.rules.RuleSet;
import goal.core.program.validation.Validator;
import goal.core.program.validation.ValidatorError;
import goal.core.program.validation.ValidatorWarning;
import goal.parser.InputStreamPosition;
import goal.tools.unittest.testsection.DoActionSection;

import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;

/**
 * {@link Validator} for {@link Module}s.<br>
 *
 * Checks for the following errors:
 * <ul>
 * <li>Goals in the <code>goals</code> section with free variables that are not
 * instantiated by the module's parameters.</li>
 * <li>The presence of a <code>beliefs</code> section in any other module than
 * the <code>init</code> module.</li>
 * <li>The absence of the <code><program</code> section in any other module than
 * the <code>init</code> module.</li>
 * <li>Errors in rules (see {@link RuleValidator})</li>
 * <li>Errors in actions (see {@link ActionValidator})</li>
 * </ul>
 *
 * Checks for the following warnings:
 * <ul>
 * <li>The absence of a reference to the module (unless it is the init, event or
 * main module)</li>
 * <li>Warnings generated by rules (see {@link RuleValidator})</li>
 * <li>Warnings generated by actions (see {@link ActionValidator})</li>
 * <li>Unused action specifications</li>
 * <li>Variable names in action specifications that are the same as variables
 * bound by the module's parameters. (one per name per specification)</li>
 * </ul>
 *
 * @author N.Kraayenbrink
 * @author K.Hindriks
 *
 */
public class ModuleValidator extends Validator<Module> {

	/**
	 * <p>
	 * The {@link Var}iables that have been bound by the context of this
	 * {@link Module}. These variables are only relevant for <i>anonymous</i>
	 * {@link Module}s as these are 'transparent' and use any bindings that have
	 * been created in the context of such modules. Variables within an
	 * anonymous module are bound by e.g. the {@link MentalStateCond}ition of a
	 * {@link Rule} that has the module as its head and by explicit parameters
	 * of parent modules. These variables are used to statically check whether
	 * all variables in {@link DoActionSection}s will be bound at runtime if all
	 * relevant variables in the action's context are properly instantiated.
	 * </p>
	 * <p>
	 * Note that a <i>regular</i> {@link Module} binds variables that occur in
	 * its {@link RuleSet} by means of its parameters (but any variables that
	 * get bound in the context of such a module are ignored).
	 * </p>
	 */
	private Set<Var> boundVar;
	/**
	 * The {@link Module}s available in the scope of the module that is
	 * validated.
	 */
	private final NameSpace parent;

	/**
	 * Returns a new instance of a {@link ModuleValidator}.
	 *
	 * @param parent
	 *            The namespace this module is in
	 * @param boundVar
	 *            Variables that have been bound by the context of this module
	 */
	public ModuleValidator(NameSpace parent, Set<Var> boundVar) {
		this.parent = parent;
		this.boundVar = new LinkedHashSet<>(boundVar);
	}

	@Override
	protected void doValidate(Module subject) {
		// Validate the name space.
		// Clone the name space; we are going to use and modify this space but
		// do not want to modify the original name space.
		NameSpace nameSpace = subject.getNameSpace().clone();
		// The name space inherits definitions (action specs, macros, modules)
		// from its parent.
		// Local definitions of this name space override those from the
		// parent's.
		nameSpace.inherit(parent, true);

		NameSpaceValidator nameSpaceValidator = new NameSpaceValidator();
		nameSpaceValidator.validate(nameSpace, this.mod2g);
		nameSpaceValidator.reportToSuperior(this);

		// Update the set of variables that are bound.
		if (!subject.getType().equals(TYPE.ANONYMOUS)) {
			// Only module parameters of a regular module bind variables.
			// Ignore any other variables that may have been bound in the
			// module's context.
			this.boundVar = new LinkedHashSet<>(0);
		}
		// Add variables bound by the parameters of the module itself.
		for (Term parameter : subject.getParameters()) {
			this.boundVar.addAll(parameter.getFreeVar());
		}

		checkParameters(subject.getParameters(), "module", subject.getSource());

		// Validate the goals section of this module.
		// Check whether all goals are closed (TRAC #1204).
		// Take into account that variables may be instantiated by parameters
		// of this module, and do not simply call 'isClosed()'.
		for (Update goal : subject.getGoals()) {
			Set<Var> freeGoalVars = goal.getFreeVar();
			freeGoalVars.removeAll(boundVar);
			if (!freeGoalVars.isEmpty()) {
				report(new ValidatorError(
						GOALError.GOAL_UNINSTANTIATED_VARIABLE, goal,
						goal.getSignature(), freeGoalVars.toString()));
			}
		}

		// Validate the program section of this module and resolve names that
		// may either refer to user specified action or to modules by means of
		// rule validators.
		if (subject.getRuleSet() != null) {
			if (subject.getRuleSet().isEmpty()) {
				if (!subject.getType().equals(TYPE.INIT)) {
					// Modules other than the init module must have at least one
					// rule.
					report(new ValidatorWarning(
							GOALWarning.MODULE_EMPTY_PROGRAMSECTION,
							subject.getRuleSet(), subject.getName()));
				}
			} else {
				// Validate the rules in the program section of the module.
				if (subject.getType() == TYPE.INIT
						|| subject.getType() == TYPE.EVENT) {
					for (Rule rule : subject.getRuleSet()) {
						if (RuleValidator.countOfExitModuleActions(rule) > 0) {
							report(new ValidatorError(
									GOALError.EXITMODULE_NOTALLOWEDHERE, rule,
									subject.getName(), subject.getType()
									.toString()));
						}
					}
				}
				RuleSetValidator ruleSetValidator = new RuleSetValidator(
						nameSpace, this.boundVar);
				ruleSetValidator.validate(subject.getRuleSet(), this.mod2g);
				ruleSetValidator.reportToSuperior(this);
			}
		} else { // RuleSet == null
			report(new ValidatorError(GOALError.MODULE_MISSING_PROGRAM_SECTION,
					subject, subject.getName()));
		}

		// Validate the non-anonymous child modules of this module.
		// Anonymous modules are validated when the corresponding FocusAction is
		// validated
		// by the ActionValidator.
		for (Module child : subject.getNameSpace().getModules().getItemList()) {
			if (!child.isAnonymous()) {
				ModuleValidator moduleValidator = new ModuleValidator(
						nameSpace, this.boundVar);
				moduleValidator.validate(child, this.mod2g);
				moduleValidator.reportToSuperior(this);
			}
		}

		// Validate the action specifications of this module.
		ActionSpecificationValidator actionSpecValidator = new ActionSpecificationValidator(
				boundVar);
		for (ActionSpecification actionSpec : subject.getActionSpecifications()) {
			actionSpecValidator.validate(actionSpec, this.mod2g);
			actionSpecValidator.reportToSuperior(this);
		}

		// Check whether all LOCAL definitions (action specs, modules, macros)
		// in the module's name space
		// have been used, except when this is the <code>init</code> module
		// (because definitions of this
		// module can be used globally).
		if (!subject.getType().equals(TYPE.INIT) && !this.mod2g) {
			// Check whether action specifications have been used.
			for (ActionSpecification actionSpec : subject.getNameSpace()
					.getActionSpecifications().getItemList()) {
				if (!actionSpec.isUsed()) {
					report(new ValidatorWarning(GOALWarning.ACTION_NEVER_USED,
							actionSpec, actionSpec.getSignature()));
				}
			}
			// Check whether (child) modules have been used.
			for (Module module : subject.getNameSpace().getModules()
					.getItemList()) {
				if (!module.isUsed()) {
					report(new ValidatorWarning(GOALWarning.MODULE_NEVER_USED,
							module, module.getName()));
				}
			}
			// Check whether defined macros are unused or defined more than
			// once.
			for (Macro macro : subject.getNameSpace().getMacros().getItemList()) {
				validateMacro(macro);
			}
		}
	}

	/**
	 * The variables that have been bound by the context of this {@link Module}.
	 *
	 * @param boundVar
	 *            The set of variables bound by this {@link Module}'s context.
	 */
	public void setBoundVar(Set<Var> boundVar) {
		this.boundVar = boundVar;
	}

	/**
	 * Checks whether a macro is used, and, if that is not the case, a warning
	 * is generated. If it has non-variable or unused parameters, a warning is
	 * also generated.
	 *
	 * @param macro
	 *            The macro to check.
	 */
	private void validateMacro(Macro macro) {
		if (!macro.isUsed()) {
			report(new ValidatorWarning(GOALWarning.MACRO_NEVER_USED, macro,
					macro.getSignature()));
		}
		// Check that macro parameters are variables.
		boolean valid = checkParameters(macro.getParameters(), "macro",
				macro.getSource());
		if (valid) {
			// Check for unused parameters.
			List<Term> unusedParameters = new ArrayList<>(macro.getParameters());
			unusedParameters.removeAll(macro.getDefinition().getFreeVar());
			if (!unusedParameters.isEmpty()) {
				report(new ValidatorWarning(
						GOALWarning.MACRO_PARAMETERS_NOTIN_DEFINITION, macro,
						macro.getSignature(), unusedParameters.toString()));
			}
		}
	}

	private boolean checkParameters(List<Term> parameters, String itemName,
			InputStreamPosition source) {
		boolean valid = true;
		int counter = 0;
		for (Term parameter : parameters) {
			// Check whether parameter is variable.
			if (!parameter.isVar()) {
				report(new ValidatorError(GOALError.MODULE_INVALID_PARAMETER,
						source, itemName, parameter.toString()));
				valid = false;
			} else
				// Check whether parameter is unique (variable) by checking that
				// it did not occur already earlier on in parameter list.
				if (parameters.subList(0, counter).contains(parameter)) {
					report(new ValidatorError(GOALError.MODULE_DUPLICATE_PARAMETER,
							source, itemName, parameter.toString()));
					valid = false;
				}
			// Increase count of number of parameters.
			counter++;
		}
		return valid;
	}

}
