init module {
	knowledge{
		% meeting conflicts if there is a scheduled meeting that overlaps in time and shares at least one attendee.
		% case 1: an existing meeting starts after the meeting being examined begins and begins before that meeting ends. 
		meeting_conflict(Date, Time, Duration, Attendees) :- 
			meeting(Date2, Time2, Dur2, Att2), % there is some other meeting.
			not(intersection(Attendees,Att2,[])), % that shares one or more attendees, i.e. the intersection is *not* empty.
			before(Date, Time, Date2, Time2),
			ends(Date, Time, Duration, End_date, End_time),
			before(Date2, Time2, End_date, End_time).
		
		% case 2: an existing meeting starts before the meeting being examined begins and ends after that meeting begins.
		meeting_conflict(Date, Time, Duration, Attendees) :- 
			meeting(Date2, Time2, Dur2, Att2), % there is some other meeting.
			not(intersection(Attendees,Att2,[])), % that shares one or more attendees, i.e. the intersection is *not* empty.
			before(Date2, Time2, Date, Time),
			ends(Date2, Time2, Dur2, End_date, End_time),
			before(Date, Time, End_date, End_time).
			
		% one date is before another if:
		before(date(D1, M1, Y1), time(Hr1,Min1), date(D2, M2, Y2), time(Hr2,Min2)) :- Y1 < Y2. % it ocurs in an earlier year 
		before(date(D1, M1, Y1), time(Hr1,Min1), date(D2, M2, Y2), time(Hr2,Min2)) :- Y1 = Y2, M1 < M2. % it occurs in an earlier month
		before(date(D1, M1, Y1), time(Hr1,Min1), date(D2, M2, Y2), time(Hr2,Min2)) :- Y1 = Y2, M1 = M2, D1 < D2. % etc
		before(date(D1, M1, Y1), time(Hr1,Min1), date(D2, M2, Y2), time(Hr2,Min2)) :- Y1 = Y2, M1 = M2, D1 = D2, Hr1 < Hr2.
		before(date(D1, M1, Y1), time(Hr1,Min1), date(D2, M2, Y2), time(Hr2,Min2)) :- Y1 = Y2, M1 = M2, D1 = D2, Hr1 = Hr2, Min1 < Min2.

		% computes the end date and time given a starting date, time and duration.
		ends(date(D, M, Y), time(H,Min), duration(H_duration,M_duration), date(D_end, M_end, Y_end), time(H_end,Min_end)) :- 
			Hours is H + H_duration, Mins is Min + M_duration, 
			date_time_stamp(date(Y, M, D, Hours, Mins, 0, 0, cet, true), Stamp), 
			stamp_date_time(Stamp, date(Y_end, M_end, D_end, H_end, Min_end, _, _, _, _), 0).
			
		% additional predicate definitions
		del([], X, []).
		del([X|T], X, T).
		del([H|T], X, L) :- not(H = X), del(T, X, L1), L = [H|L1].
	}
	
	beliefs{
		% calendar
		meeting(date(26, 01, 2010), time(12,30), duration(1,30), [jane, tarzan]).
	}
	
	goals{
		meeting(date(15, 02, 2010), time(18,00), duration(4,00), [jane]).
	}
		
	actionspec{
		% write meeting in calendar
		createMeeting(Date, Time, Duration, Attendees)@int {
			pre{
				not(meeting_conflict(Date, Time, Duration, Attendees))
			}
			post{
				meeting(Date, Time, Duration, Attendees)
			}
		}
	}
}
	
main module {
	program [order=random] {
		#define not_yet_invited(Person, Date, Time, Duration, Attendees)
			goal(meeting(Date, Time, Duration, Attendees)), bel(member(Person, Attendees), me(Me), not(Person = Me)),
			not(bel(sent(Person, meeting(Date, Time, Duration, Attendees)))).
		#define non_conflicting_meeting_invitation(Inviter, Date, Time, Duration, Attendees)
			bel(received(Inviter, meeting(Date, Time, Duration, Attendees)), not(meeting_conflict(Date, Time, Duration, Attendees))).
		#define meeting_invitation_accepted_by_all(Date, Time, Duration, Attendees)
			goal(meeting(Date, Time, Duration, Attendees)), bel(me(Me), del(Attendees, Me, Others), forall(member(X, Others), received(X, accept(Date, Time, Duration, Attendees)))).
		
		% send invitations
		if not_yet_invited(Person, Date, Time, Dur, Att)
			then (Person).send(meeting(Date, Time, Dur, Att)).
		
		% create a meeting appointment in the calendar
		if non_conflicting_meeting_invitation(Inviter, Date, Time, Dur, Att)
			then createMeeting(Date, Time, Dur, Att) + insert(not(received(Inviter, meeting(Date, Time, Dur, Att)))) + (Inviter).send(accept(Date, Time, Dur, Att)).
		if meeting_invitation_accepted_by_all(Date, Time, Dur, Att)
			then createMeeting(Date, Time, Dur, Att).
	}
}
