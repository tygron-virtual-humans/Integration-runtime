% This agent moves blocks to the table or performs a skip action (which do nothing).

% Initialize the agent and it's mental state.
init module {
	knowledge {
		% only blocks can be on top of another object.
	    block(X) :- on(X, _).
       	% a block is clear if nothing is on top of it.
       	clear(X) :- block(X), not( on(_, X) ).
		% the table is always clear.
		clear(table).
		
		% allClear succeeds if all blocks are clear.
		% note that allClear also succeeds if there are no blocks.
		allClear :- forall(block(X), clear(X)).
	}
	program {
		% first insert all percepts into the agent's belief base
		forall bel( percept( on(X, Y) ) ) do insert( on(X, Y) ).
		% then adopt a goal to clear all blocks
		% (in this order to make sure that the agent does not believe
		% allClear has been achieved just because there are no blocks).
		if true then adopt(allClear).
	}
	actionspec {
		% moves a block on top of another block or to the table.
		move(X, Y) {
		   % a block can only be moved elsewhere if that block and the place to move it to are both clear.
		   % on(X, Z) retrieves the current (and soon to be old) position where block X sits on.  
		   % not( on(X,Y) ) prevents an agent from moving a block on the table to another place on the table.
		   % because a block cannot be put on top of itself not( X=Y ) is included in the precondition.
		   pre { clear(X), clear(Y), on(X, Z), not( on(X, Y) ), not( X=Y ) }
		   % effect of moving block X on top of Y is that we have on(X, Y).
		   % after moving, block X is no longer on top of Z and we remove on(X, Z).
		   post { not( on(X, Z) ), on(X, Y) }
		}
		% skip action; can always be performed and does not do/change anything.
		% @int declares action to be internal action and prevents sending the action to the environment.
		skip@int {
			pre { true }
			post { true }
		}
	}
}

% Decide on an action to perform.
main module [exit=nogoals] {
	% randomly select to move a block to the table (if possible) or to perform skip.
	program [order=random] {
		if bel( on(X,Y) ) then move(X,table).
		if true then skip.
	}
}

% Process any percepts the agent receives.
event module {
	program {
		% the Blocks World is fully observable.
		forall bel( percept( on(X, Y) ), not( on(X, Y) ) ) do insert( on(X, Y) ).
		forall bel( on(X, Y), not( percept( on(X, Y) ) ) ) do delete( on(X, Y) ).
	}
}