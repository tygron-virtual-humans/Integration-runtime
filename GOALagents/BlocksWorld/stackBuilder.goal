% This agent moves blocks in order to achieve a target configuration of blocks (the goal in its goal base).

% Initialize the agent and it's mental state.
init module {
	knowledge {
		% only blocks can be on top of another object.
		block(X) :- on(X, _).
		% a block is clear if nothing is on top of it.
       	clear(X) :- block(X), not( on(_, X) ).
		% the table is always clear.
		clear(table).
		% a tower is any non-empty stack of blocks that sits on the table.
		tower([X]) :- on(X, table).
		tower([X, Y| T]) :- on(X, Y), tower([Y| T]).
	}
	goals {
		% a single goal to achieve a particular configuration of blocks.
		% assumes that these blocks are available in the Blocks World.
		on(b1,b5), on(b2,table), on(b3,table), on(b4,b3), on(b5,b2), on(b6,b4), on(b7,table).
	}
	actionspec {
		% moves a block on top of another block or to the table.
		move(X, Y) {
		   % a block can only be moved elsewhere if that block and the place to move it to are both clear.
		   % on(X, Z) retrieves the current (and soon to be old) position where block X sits on.  
		   % not( on(X,Y) ) prevents an agent from moving a block on the table to another place on the table.
		   % because a block cannot be put on top of itself not( X=Y ) is included in the precondition.
		   pre { clear(X), clear(Y), on(X, Z), not( on(X, Y) ), not( X=Y ) }
		   % effect of moving block X on top of Y is that we have on(X, Y).
		   % after moving, block X is no longer on top of Z and we remove on(X, Z).
		   post { not( on(X, Z) ), on(X, Y) }
		}
	}
}

% Decide on an action to perform in Blocks World.
main module [exit=nogoals] {
	program {
		#define misplaced(X) a-goal(tower([X| T])).
		#define constructiveMove(X,Y) a-goal(tower([X, Y| T])), bel(tower([Y| T])).
		
		if constructiveMove(X, Y) then move(X, Y).
		if misplaced(X) then move(X, table).
	}
}

% Process any percepts the agent receives.
event module {
	program {
		% the Blocks World is fully observable.
		forall bel( percept( on(X, Y) ), not( on(X, Y) ) ) do insert( on(X, Y) ).
		forall bel( on(X, Y), not( percept( on(X, Y) ) ) ) do delete( on(X, Y) ).
	}
}