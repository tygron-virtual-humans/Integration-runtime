init module {
	knowledge {
		% A room is a place with exactly one neighbour, i.e., there is only one way to get to and from that place.
		room(PlaceID) :- zone(_,PlaceID,_,_,Neighbours), length(Neighbours,1).
		
		% Assignment II.2: insert a definition of the predicate "nextColorInSeq(Color)".
	}
	program {
		% Store map information, i.e., navigation points in the agent's belief base.
		forall bel( percept(zone(ID, Name, X, Y, Neighbours)) ) do insert( zone(ID, Name, X, Y, Neighbours) ).

		% Record current state of movement in belief base.
		forall bel( percept(state(State)) ) do insert( state(State) ).
		
		% Adopt initial goals.
		forall bel( room(Place) ) do adopt( in(Place) ).

		% Assignment II.1a: insert here rules for processing "sendonce" percepts that are sent only at the beginning of a session.
	}	
	actionspec {
		% The goTo action makes the agent move to a place (location) in the BW4T environment.
		% As long as the agent has not arrived at the place it is going to, it will be in "traveling" mode.
		goTo(Location) {
            pre { not(state(traveling)) }
			post { true }
		}

		% Assignment II.3a: insert a specification for the goToBlock(Block) action.

		% Assignment II.3b: insert a specification for the pickUp action.

		% Assignment II.3c: insert a specification for the putDown action.
	}
}

main module {
	program {
		if a-goal( in(Place) ) then goTo(Place).

		% Assignment II.5: improve the two lines of code above such that the agent 
		%   checks the rooms in a more efficient way (not checking the same room 
		%   twice, for example).

		% Assignment II.6: insert code that makes the agent deliver a block when it 
		%   knows about a block that can be delivered. Make sure you use the goal base
		%	to set goals where the agent should go.

		% Assignment III.2: implement dealing with unexpected block removal.

		% Assignment III.3: implement dealing with unexpected block delivery.
	}
}

event module {
	program {
		forall bel( state(State), percept(state(NewState)) ) do delete( state(State) ) + insert( state(NewState) ).
		
		forall bel( percept(in(Place)) ) do insert( in(Place) ).
		forall bel( percept(not(in(Place))) ) do delete( in(Place) ).

		% Assignment II.1b: insert percept rules for handling percepts other than send once percepts.

		%%%%%%%%%%%%%%%%%% sending messages and processing received messages %%%%%%%%%%%%%%%%%%%%
		% Assignment III.5b: insert one or more rule(s) for messages sent by other agents.

		% Assignment III.5a: insert send-actions to implement the communication of your choice.
	}
}
